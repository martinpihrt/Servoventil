
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486/servoventil_1.0.0.ino.elf:     file format elf32-avr


Disassembly of section .text:

00000000 <__vectors>:
__vectors():
       0:	0c 94 53 00 	jmp	0xa6	; 0xa6 <__ctors_end>
       4:	0c 94 7b 00 	jmp	0xf6	; 0xf6 <__bad_interrupt>
       8:	0c 94 7b 00 	jmp	0xf6	; 0xf6 <__bad_interrupt>
       c:	0c 94 7b 00 	jmp	0xf6	; 0xf6 <__bad_interrupt>
      10:	0c 94 7b 00 	jmp	0xf6	; 0xf6 <__bad_interrupt>
      14:	0c 94 7b 00 	jmp	0xf6	; 0xf6 <__bad_interrupt>
      18:	0c 94 7b 00 	jmp	0xf6	; 0xf6 <__bad_interrupt>
      1c:	0c 94 c6 03 	jmp	0x78c	; 0x78c <__vector_7>
      20:	0c 94 7b 00 	jmp	0xf6	; 0xf6 <__bad_interrupt>
      24:	0c 94 7b 00 	jmp	0xf6	; 0xf6 <__bad_interrupt>
      28:	0c 94 7b 00 	jmp	0xf6	; 0xf6 <__bad_interrupt>
      2c:	0c 94 7b 00 	jmp	0xf6	; 0xf6 <__bad_interrupt>
      30:	0c 94 7c 03 	jmp	0x6f8	; 0x6f8 <__vector_12>
      34:	0c 94 7b 00 	jmp	0xf6	; 0xf6 <__bad_interrupt>
      38:	0c 94 7b 00 	jmp	0xf6	; 0xf6 <__bad_interrupt>
      3c:	0c 94 7b 00 	jmp	0xf6	; 0xf6 <__bad_interrupt>
      40:	0c 94 7b 00 	jmp	0xf6	; 0xf6 <__bad_interrupt>
      44:	0c 94 7b 00 	jmp	0xf6	; 0xf6 <__bad_interrupt>
      48:	0c 94 7b 00 	jmp	0xf6	; 0xf6 <__bad_interrupt>
      4c:	0c 94 7b 00 	jmp	0xf6	; 0xf6 <__bad_interrupt>
      50:	0c 94 7b 00 	jmp	0xf6	; 0xf6 <__bad_interrupt>
      54:	0c 94 7b 00 	jmp	0xf6	; 0xf6 <__bad_interrupt>
      58:	0c 94 7b 00 	jmp	0xf6	; 0xf6 <__bad_interrupt>
      5c:	0c 94 fd 04 	jmp	0x9fa	; 0x9fa <__vector_23>
      60:	0c 94 82 04 	jmp	0x904	; 0x904 <__vector_24>
      64:	0c 94 7b 00 	jmp	0xf6	; 0xf6 <__bad_interrupt>
      68:	0c 94 7b 00 	jmp	0xf6	; 0xf6 <__bad_interrupt>
      6c:	0c 94 7b 00 	jmp	0xf6	; 0xf6 <__bad_interrupt>

00000070 <__trampolines_end>:
__trampolines_start():
      70:	00 30       	cpi	r16, 0x00	; 0
      72:	2c 28       	or	r2, r12

00000074 <port_to_pullup_PGM>:
      74:	00 32 2e 2a                                         .2.*

00000078 <port_to_output_PGM>:
      78:	00 31 2d 29                                         .1-)

0000007c <port_to_input_PGM>:
      7c:	00 2f 2b 27                                         ./+'

00000080 <digital_pin_to_port_PGM>:
      80:	02 01 01 01 01 01 01 01 01 03 03 03 03 03 02 02     ................
      90:	02 03                                               ..

00000092 <digital_pin_to_bit_mask_PGM>:
      92:	01 80 40 20 10 08 04 02 01 20 10 04 02 01 08 04     ..@ ..... ......
      a2:	02 08                                               ..

000000a4 <__ctors_start>:
__ctors_start():
      a4:	63 07       	cpc	r22, r19

000000a6 <__ctors_end>:
__dtors_end():
      a6:	11 24       	eor	r1, r1
      a8:	1f be       	out	0x3f, r1	; 63
      aa:	cf ef       	ldi	r28, 0xFF	; 255
      ac:	d4 e0       	ldi	r29, 0x04	; 4
      ae:	de bf       	out	0x3e, r29	; 62
      b0:	cd bf       	out	0x3d, r28	; 61

000000b2 <__do_copy_data>:
__do_copy_data():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr35/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2409
      b2:	11 e0       	ldi	r17, 0x01	; 1
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr35/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2410
      b4:	a0 e0       	ldi	r26, 0x00	; 0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr35/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2411
      b6:	b1 e0       	ldi	r27, 0x01	; 1
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr35/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2412
      b8:	ec e0       	ldi	r30, 0x0C	; 12
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr35/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2413
      ba:	f0 e1       	ldi	r31, 0x10	; 16
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr35/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2414
      bc:	02 c0       	rjmp	.+4      	; 0xc2 <__do_copy_data+0x10>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr35/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2417
      be:	05 90       	lpm	r0, Z+
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr35/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2422
      c0:	0d 92       	st	X+, r0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr35/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2424
      c2:	a4 30       	cpi	r26, 0x04	; 4
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr35/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2425
      c4:	b1 07       	cpc	r27, r17
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr35/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2426
      c6:	d9 f7       	brne	.-10     	; 0xbe <__do_copy_data+0xc>

000000c8 <__do_clear_bss>:
__do_clear_bss():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr35/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2441
      c8:	21 e0       	ldi	r18, 0x01	; 1
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr35/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2442
      ca:	a4 e0       	ldi	r26, 0x04	; 4
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr35/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2443
      cc:	b1 e0       	ldi	r27, 0x01	; 1
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr35/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2444
      ce:	01 c0       	rjmp	.+2      	; 0xd2 <.do_clear_bss_start>

000000d0 <.do_clear_bss_loop>:
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr35/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2446
      d0:	1d 92       	st	X+, r1

000000d2 <.do_clear_bss_start>:
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr35/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2448
      d2:	a3 36       	cpi	r26, 0x63	; 99
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr35/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2449
      d4:	b2 07       	cpc	r27, r18
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr35/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2450
      d6:	e1 f7       	brne	.-8      	; 0xd0 <.do_clear_bss_loop>

000000d8 <__do_global_ctors>:
__do_global_ctors():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr35/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2466
      d8:	10 e0       	ldi	r17, 0x00	; 0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr35/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2467
      da:	c3 e5       	ldi	r28, 0x53	; 83
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr35/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2468
      dc:	d0 e0       	ldi	r29, 0x00	; 0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr35/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2472
      de:	04 c0       	rjmp	.+8      	; 0xe8 <__do_global_ctors+0x10>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr35/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2474
      e0:	21 97       	sbiw	r28, 0x01	; 1
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr35/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2480
      e2:	fe 01       	movw	r30, r28
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr35/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2481
      e4:	0e 94 fe 07 	call	0xffc	; 0xffc <__tablejump2__>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr35/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2483
      e8:	c2 35       	cpi	r28, 0x52	; 82
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr35/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2484
      ea:	d1 07       	cpc	r29, r17
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr35/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2489
      ec:	c9 f7       	brne	.-14     	; 0xe0 <__do_global_ctors+0x8>
      ee:	0e 94 66 05 	call	0xacc	; 0xacc <main>
      f2:	0c 94 04 08 	jmp	0x1008	; 0x1008 <_exit>

000000f6 <__bad_interrupt>:
__vector_22():
      f6:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000fa <TwoWire::beginTransmission(unsigned char) [clone .constprop.21]>:
_ZN7TwoWire17beginTransmissionEh.constprop.21():
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/Wire.cpp:453
  return requestFrom((uint8_t)address, (uint8_t)quantity, (uint8_t)sendStop);
}

void TwoWire::beginTransmission(uint8_t address) {
  // indicate that we are transmitting
  transmitting = 1;
      fa:	91 e0       	ldi	r25, 0x01	; 1
      fc:	90 93 62 01 	sts	0x0162, r25	; 0x800162 <TwoWire::transmitting>
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/Wire.cpp:455
  // set address of targeted slave and write mode
  Buffer[0] = (address << TWI_ADR_BITS) | (0 << TWI_READ_BIT);
     100:	88 0f       	add	r24, r24
     102:	80 93 04 01 	sts	0x0104, r24	; 0x800104 <__data_end>
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/Wire.cpp:457
  // reset tx buffer iterator vars
  BufferIndex = 1; // reserved by slave address
     106:	90 93 61 01 	sts	0x0161, r25	; 0x800161 <TwoWire::BufferIndex>
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/Wire.cpp:458
  BufferLength = BufferIndex;
     10a:	90 93 60 01 	sts	0x0160, r25	; 0x800160 <TwoWire::BufferLength>
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/Wire.cpp:459
}
     10e:	08 95       	ret

00000110 <TwoWire::write(unsigned char) [clone .constprop.17]>:
_ZN7TwoWire5writeEh.constprop.17():
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/Wire.cpp:498

// must be called in:
// slave tx event callback
// or after beginTransmission(address)
size_t TwoWire::write(uint8_t data) {
  if (transmitting) { // in master transmitter mode
     110:	90 91 62 01 	lds	r25, 0x0162	; 0x800162 <TwoWire::transmitting>
     114:	99 23       	and	r25, r25
     116:	a1 f0       	breq	.+40     	; 0x140 <TwoWire::write(unsigned char) [clone .constprop.17]+0x30>
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/Wire.cpp:500
    // don't bother if buffer is full
    if (BufferLength >= TWI_BUFFER_SIZE) {
     118:	90 91 60 01 	lds	r25, 0x0160	; 0x800160 <TwoWire::BufferLength>
     11c:	90 32       	cpi	r25, 0x20	; 32
     11e:	40 f5       	brcc	.+80     	; 0x170 <TwoWire::write(unsigned char) [clone .constprop.17]+0x60>
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/Wire.cpp:504
      return 0;
    }
    // put byte in tx buffer
    Buffer[BufferIndex] = data;
     120:	90 91 61 01 	lds	r25, 0x0161	; 0x800161 <TwoWire::BufferIndex>
     124:	e9 2f       	mov	r30, r25
     126:	f0 e0       	ldi	r31, 0x00	; 0
     128:	ec 5f       	subi	r30, 0xFC	; 252
     12a:	fe 4f       	sbci	r31, 0xFE	; 254
     12c:	80 83       	st	Z, r24
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/Wire.cpp:505
    ++BufferIndex;
     12e:	81 e0       	ldi	r24, 0x01	; 1
     130:	89 0f       	add	r24, r25
     132:	80 93 61 01 	sts	0x0161, r24	; 0x800161 <TwoWire::BufferIndex>
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/Wire.cpp:507
    // update amount in buffer
    BufferLength = BufferIndex;
     136:	80 93 60 01 	sts	0x0160, r24	; 0x800160 <TwoWire::BufferLength>
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/Wire.cpp:516
      return 0;
    }
    // reply to master
    USI_TWI_Transmit_Byte(data);
  }
  return 1;
     13a:	81 e0       	ldi	r24, 0x01	; 1
     13c:	90 e0       	ldi	r25, 0x00	; 0
     13e:	08 95       	ret
USI_TWI_Space_In_Transmission_Buffer():
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/USI_TWI_Slave.c:144

// Check if there is space in the transmission buffer.
unsigned char USI_TWI_Space_In_Transmission_Buffer(void)
{
  unsigned char tmpTxHead;
  tmpTxHead = (TWI_TxHead + 1) & TWI_TX_BUFFER_MASK; // Calculate next buffer index.
     140:	20 91 5e 01 	lds	r18, 0x015E	; 0x80015e <TWI_TxHead>
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/USI_TWI_Slave.c:145
  return (TWI_TxTail - tmpTxHead) & TWI_TX_BUFFER_MASK; // Return 0 (FALSE) if the transmission buffer is full.
     144:	90 91 5d 01 	lds	r25, 0x015D	; 0x80015d <TWI_TxTail>
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/USI_TWI_Slave.c:144

// Check if there is space in the transmission buffer.
unsigned char USI_TWI_Space_In_Transmission_Buffer(void)
{
  unsigned char tmpTxHead;
  tmpTxHead = (TWI_TxHead + 1) & TWI_TX_BUFFER_MASK; // Calculate next buffer index.
     148:	2f 5f       	subi	r18, 0xFF	; 255
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/USI_TWI_Slave.c:145
  return (TWI_TxTail - tmpTxHead) & TWI_TX_BUFFER_MASK; // Return 0 (FALSE) if the transmission buffer is full.
     14a:	92 1b       	sub	r25, r18
     14c:	9f 70       	andi	r25, 0x0F	; 15
_ZN7TwoWire5writeEh.constprop.17():
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/Wire.cpp:510
    ++BufferIndex;
    // update amount in buffer
    BufferLength = BufferIndex;
  } else { // in slave send mode
    // don't bother if buffer is full
    if (!USI_TWI_Space_In_Transmission_Buffer()) {
     14e:	81 f0       	breq	.+32     	; 0x170 <TwoWire::write(unsigned char) [clone .constprop.17]+0x60>
USI_TWI_Transmit_Byte():
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/USI_TWI_Slave.c:100
// Puts data in the transmission buffer, Waits if buffer is full.
void USI_TWI_Transmit_Byte(unsigned char data)
{
  unsigned char tmphead;

  tmphead = (TWI_TxHead + 1) & TWI_TX_BUFFER_MASK; // Calculate buffer index.
     150:	90 91 5e 01 	lds	r25, 0x015E	; 0x80015e <TWI_TxHead>
     154:	9f 5f       	subi	r25, 0xFF	; 255
     156:	9f 70       	andi	r25, 0x0F	; 15
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/USI_TWI_Slave.c:101
  while (tmphead == TWI_TxTail)
     158:	20 91 5d 01 	lds	r18, 0x015D	; 0x80015d <TWI_TxTail>
     15c:	92 17       	cp	r25, r18
     15e:	e1 f3       	breq	.-8      	; 0x158 <TwoWire::write(unsigned char) [clone .constprop.17]+0x48>
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/USI_TWI_Slave.c:103
    ;                         // Wait for free space in buffer.
  TWI_TxBuf[tmphead] = data;    // Store data in buffer.
     160:	e9 2f       	mov	r30, r25
     162:	f0 e0       	ldi	r31, 0x00	; 0
     164:	ec 5e       	subi	r30, 0xEC	; 236
     166:	fe 4f       	sbci	r31, 0xFE	; 254
     168:	80 83       	st	Z, r24
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/USI_TWI_Slave.c:104
  TWI_TxHead         = tmphead; // Store new index.
     16a:	90 93 5e 01 	sts	0x015E, r25	; 0x80015e <TWI_TxHead>
     16e:	e5 cf       	rjmp	.-54     	; 0x13a <TwoWire::write(unsigned char) [clone .constprop.17]+0x2a>
_ZN7TwoWire5writeEh.constprop.17():
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/Wire.cpp:501
// or after beginTransmission(address)
size_t TwoWire::write(uint8_t data) {
  if (transmitting) { // in master transmitter mode
    // don't bother if buffer is full
    if (BufferLength >= TWI_BUFFER_SIZE) {
      return 0;
     170:	90 e0       	ldi	r25, 0x00	; 0
     172:	80 e0       	ldi	r24, 0x00	; 0
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/Wire.cpp:517
    }
    // reply to master
    USI_TWI_Transmit_Byte(data);
  }
  return 1;
}
     174:	08 95       	ret

00000176 <TwoWire::read() [clone .constprop.12]>:
_ZN7TwoWire4readEv.constprop.12():
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/Wire.cpp:542

// must be called in:
// slave rx event callback
// or after requestFrom(address, numBytes)
int TwoWire::available(void) {
  if (BufferLength) {
     176:	80 91 60 01 	lds	r24, 0x0160	; 0x800160 <TwoWire::BufferLength>
     17a:	88 23       	and	r24, r24
     17c:	39 f0       	breq	.+14     	; 0x18c <TwoWire::read() [clone .constprop.12]+0x16>
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/Wire.cpp:543
    return BufferLength - BufferIndex;
     17e:	20 91 61 01 	lds	r18, 0x0161	; 0x800161 <TwoWire::BufferIndex>
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/Wire.cpp:556
// or after requestFrom(address, numBytes)
int TwoWire::read(void) {
  int value = -1;

  // get each successive byte on each call
  if (available()) {
     182:	82 13       	cpse	r24, r18
     184:	1c c0       	rjmp	.+56     	; 0x1be <TwoWire::read() [clone .constprop.12]+0x48>
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/Wire.cpp:553

// must be called in:
// slave rx event callback
// or after requestFrom(address, numBytes)
int TwoWire::read(void) {
  int value = -1;
     186:	8f ef       	ldi	r24, 0xFF	; 255
     188:	9f ef       	ldi	r25, 0xFF	; 255
     18a:	08 95       	ret
USI_TWI_Data_In_Receive_Buffer():
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/USI_TWI_Slave.c:136

// Check if there is data in the receive buffer.
unsigned char USI_TWI_Data_In_Receive_Buffer(void)
{
  unsigned char tmpRxTail;          // Temporary variable to store volatile
  tmpRxTail = TWI_RxTail;           // Not necessary, but prevents warnings
     18c:	90 91 5c 01 	lds	r25, 0x015C	; 0x80015c <TWI_RxTail>
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/USI_TWI_Slave.c:137
  return (TWI_RxHead - tmpRxTail) & TWI_RX_BUFFER_MASK; // Return 0 (FALSE) if the receive buffer is empty.
     190:	80 91 5b 01 	lds	r24, 0x015B	; 0x80015b <TWI_RxHead>
     194:	89 1b       	sub	r24, r25
     196:	8f 70       	andi	r24, 0x0F	; 15
_ZN7TwoWire4readEv.constprop.12():
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/Wire.cpp:556

  // get each successive byte on each call
  if (available()) {
     198:	b1 f3       	breq	.-20     	; 0x186 <TwoWire::read() [clone .constprop.12]+0x10>
USI_TWI_Receive_Byte():
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/USI_TWI_Slave.c:112
// Returns a byte from the receive buffer. Waits if buffer is empty.
unsigned char USI_TWI_Receive_Byte(void)
{
  unsigned char tmptail;
  unsigned char tmpRxTail; // Temporary variable to store volatile
  tmpRxTail = TWI_RxTail;  // Not necessary, but prevents warnings
     19a:	90 91 5c 01 	lds	r25, 0x015C	; 0x80015c <TWI_RxTail>
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/USI_TWI_Slave.c:113
  while (TWI_RxHead == tmpRxTail)
     19e:	80 91 5b 01 	lds	r24, 0x015B	; 0x80015b <TWI_RxHead>
     1a2:	98 17       	cp	r25, r24
     1a4:	e1 f3       	breq	.-8      	; 0x19e <TwoWire::read() [clone .constprop.12]+0x28>
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/USI_TWI_Slave.c:115
    ;
  tmptail    = (TWI_RxTail + 1) & TWI_RX_BUFFER_MASK; // Calculate buffer index
     1a6:	e0 91 5c 01 	lds	r30, 0x015C	; 0x80015c <TWI_RxTail>
     1aa:	ef 5f       	subi	r30, 0xFF	; 255
     1ac:	ef 70       	andi	r30, 0x0F	; 15
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/USI_TWI_Slave.c:116
  TWI_RxTail = tmptail;                               // Store new index
     1ae:	e0 93 5c 01 	sts	0x015C, r30	; 0x80015c <TWI_RxTail>
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/USI_TWI_Slave.c:117
  return TWI_RxBuf[tmptail];                          // Return data from the buffer.
     1b2:	f0 e0       	ldi	r31, 0x00	; 0
     1b4:	ec 5f       	subi	r30, 0xFC	; 252
     1b6:	fe 4f       	sbci	r31, 0xFE	; 254
_ZN7TwoWire4readEv.constprop.12():
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/Wire.cpp:561
    if (BufferLength) {
      value = Buffer[BufferIndex];
      ++BufferIndex;
    } else {
      value = USI_TWI_Receive_Byte();
     1b8:	80 81       	ld	r24, Z
     1ba:	90 e0       	ldi	r25, 0x00	; 0
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/Wire.cpp:566
    }
  }

  return value;
}
     1bc:	08 95       	ret
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/Wire.cpp:558
  int value = -1;

  // get each successive byte on each call
  if (available()) {
    if (BufferLength) {
      value = Buffer[BufferIndex];
     1be:	e2 2f       	mov	r30, r18
     1c0:	f0 e0       	ldi	r31, 0x00	; 0
     1c2:	ec 5f       	subi	r30, 0xFC	; 252
     1c4:	fe 4f       	sbci	r31, 0xFE	; 254
     1c6:	80 81       	ld	r24, Z
     1c8:	90 e0       	ldi	r25, 0x00	; 0
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/Wire.cpp:559
      ++BufferIndex;
     1ca:	2f 5f       	subi	r18, 0xFF	; 255
     1cc:	20 93 61 01 	sts	0x0161, r18	; 0x800161 <TwoWire::BufferIndex>
     1d0:	08 95       	ret

000001d2 <Servo::write(int) [clone .constprop.4]>:
_ZN5Servo5writeEi.constprop.4():
C:\Users\táta\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\libraries\Servo_ATTinyCore\src\avr/Servo_ATTinyCore.cpp:1244
  if(isTimerActive(timer) == false) {
    finISR(timer);
  }
}

void Servo::write(int value)
     1d2:	8f 92       	push	r8
     1d4:	9f 92       	push	r9
     1d6:	af 92       	push	r10
     1d8:	bf 92       	push	r11
     1da:	ff 92       	push	r15
     1dc:	0f 93       	push	r16
     1de:	1f 93       	push	r17
     1e0:	cf 93       	push	r28
     1e2:	df 93       	push	r29
writeMicroseconds():
C:\Users\táta\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\libraries\Servo_ATTinyCore\src\avr/Servo_ATTinyCore.cpp:1258
}

void Servo::writeMicroseconds(int value)
{
  // calculate and store the values for the given channel
  byte channel = this->servoIndex;
     1e4:	f0 90 54 01 	lds	r15, 0x0154	; 0x800154 <servo>
C:\Users\táta\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\libraries\Servo_ATTinyCore\src\avr/Servo_ATTinyCore.cpp:1259
  if( (channel < MAX_SERVOS) )   // ensure channel is valid
     1e8:	2b e0       	ldi	r18, 0x0B	; 11
     1ea:	2f 15       	cp	r18, r15
     1ec:	08 f4       	brcc	.+2      	; 0x1f0 <Servo::write(int) [clone .constprop.4]+0x1e>
     1ee:	4e c0       	rjmp	.+156    	; 0x28c <Servo::write(int) [clone .constprop.4]+0xba>
     1f0:	9c 01       	movw	r18, r24
_ZN5Servo5writeEi.constprop.4():
C:\Users\táta\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\libraries\Servo_ATTinyCore\src\avr/Servo_ATTinyCore.cpp:1250
{
  if(value < MIN_PULSE_WIDTH)
  {  // treat values less than 544 as angles in degrees (valid values in microseconds are handled as microseconds)
    if(value < 0) value = 0;
    if(value > 180) value = 180;
    value = map(value, 0, 180, SERVO_MIN(),  SERVO_MAX());
     1f2:	80 91 56 01 	lds	r24, 0x0156	; 0x800156 <servo+0x2>
     1f6:	08 e5       	ldi	r16, 0x58	; 88
     1f8:	12 e0       	ldi	r17, 0x02	; 2
     1fa:	08 1b       	sub	r16, r24
     1fc:	11 09       	sbc	r17, r1
     1fe:	87 fd       	sbrc	r24, 7
     200:	13 95       	inc	r17
     202:	00 0f       	add	r16, r16
     204:	11 1f       	adc	r17, r17
     206:	00 0f       	add	r16, r16
     208:	11 1f       	adc	r17, r17
     20a:	80 91 55 01 	lds	r24, 0x0155	; 0x800155 <servo+0x1>
     20e:	c8 e8       	ldi	r28, 0x88	; 136
     210:	d0 e0       	ldi	r29, 0x00	; 0
     212:	c8 1b       	sub	r28, r24
     214:	d1 09       	sbc	r29, r1
     216:	87 fd       	sbrc	r24, 7
     218:	d3 95       	inc	r29
     21a:	cc 0f       	add	r28, r28
     21c:	dd 1f       	adc	r29, r29
     21e:	cc 0f       	add	r28, r28
     220:	dd 1f       	adc	r29, r29
     222:	4e 01       	movw	r8, r28
     224:	0d 2e       	mov	r0, r29
     226:	00 0c       	add	r0, r0
     228:	aa 08       	sbc	r10, r10
     22a:	bb 08       	sbc	r11, r11
     22c:	b8 01       	movw	r22, r16
     22e:	01 2e       	mov	r0, r17
     230:	00 0c       	add	r0, r0
     232:	88 0b       	sbc	r24, r24
     234:	99 0b       	sbc	r25, r25
map():
C:\Users\táta\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\cores\tinymodern/WMath.cpp:56
  return random(diff) + howsmall;
}

long map(long x, long in_min, long in_max, long out_min, long out_max)
{
  return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
     236:	68 19       	sub	r22, r8
     238:	79 09       	sbc	r23, r9
     23a:	8a 09       	sbc	r24, r10
     23c:	9b 09       	sbc	r25, r11
_ZN5Servo5writeEi.constprop.4():
C:\Users\táta\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\libraries\Servo_ATTinyCore\src\avr/Servo_ATTinyCore.cpp:1250
     23e:	03 2e       	mov	r0, r19
     240:	00 0c       	add	r0, r0
     242:	44 0b       	sbc	r20, r20
     244:	55 0b       	sbc	r21, r21
map():
C:\Users\táta\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\cores\tinymodern/WMath.cpp:56
     246:	0e 94 7e 07 	call	0xefc	; 0xefc <__mulsi3>
     24a:	24 eb       	ldi	r18, 0xB4	; 180
     24c:	30 e0       	ldi	r19, 0x00	; 0
     24e:	40 e0       	ldi	r20, 0x00	; 0
     250:	50 e0       	ldi	r21, 0x00	; 0
     252:	0e 94 97 07 	call	0xf2e	; 0xf2e <__divmodsi4>
     256:	82 0e       	add	r8, r18
     258:	93 1e       	adc	r9, r19
     25a:	a4 1e       	adc	r10, r20
     25c:	b5 1e       	adc	r11, r21
writeMicroseconds():
C:\Users\táta\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\libraries\Servo_ATTinyCore\src\avr/Servo_ATTinyCore.cpp:1261
{
  // calculate and store the values for the given channel
  byte channel = this->servoIndex;
  if( (channel < MAX_SERVOS) )   // ensure channel is valid
  {
    if( value < SERVO_MIN() )          // ensure pulse width is valid
     25e:	8c 16       	cp	r8, r28
     260:	9d 06       	cpc	r9, r29
     262:	2c f0       	brlt	.+10     	; 0x26e <Servo::write(int) [clone .constprop.4]+0x9c>
     264:	e8 01       	movw	r28, r16
     266:	80 16       	cp	r8, r16
     268:	91 06       	cpc	r9, r17
     26a:	0c f4       	brge	.+2      	; 0x26e <Servo::write(int) [clone .constprop.4]+0x9c>
     26c:	e4 01       	movw	r28, r8
C:\Users\táta\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\libraries\Servo_ATTinyCore\src\avr/Servo_ATTinyCore.cpp:1269
      value = SERVO_MAX();

    value = value - TRIM_DURATION;
    value = usToTicks(value);  // convert to ticks after compensating for interrupt overhead - 12 Aug 2009

    uint8_t oldSREG = SREG;
     26e:	2f b7       	in	r18, 0x3f	; 63
C:\Users\táta\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\libraries\Servo_ATTinyCore\src\avr/Servo_ATTinyCore.cpp:1270
    cli();
     270:	f8 94       	cli
C:\Users\táta\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\libraries\Servo_ATTinyCore\src\avr/Servo_ATTinyCore.cpp:1266
    if( value < SERVO_MIN() )          // ensure pulse width is valid
      value = SERVO_MIN();
    else if( value > SERVO_MAX() )
      value = SERVO_MAX();

    value = value - TRIM_DURATION;
     272:	22 97       	sbiw	r28, 0x02	; 2
C:\Users\táta\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\libraries\Servo_ATTinyCore\src\avr/Servo_ATTinyCore.cpp:1271
    value = usToTicks(value);  // convert to ticks after compensating for interrupt overhead - 12 Aug 2009

    uint8_t oldSREG = SREG;
    cli();
    servos[channel].ticks = value;
     274:	8f 2d       	mov	r24, r15
     276:	90 e0       	ldi	r25, 0x00	; 0
     278:	63 e0       	ldi	r22, 0x03	; 3
     27a:	70 e0       	ldi	r23, 0x00	; 0
     27c:	0e 94 e1 07 	call	0xfc2	; 0xfc2 <__mulhi3>
     280:	80 5d       	subi	r24, 0xD0	; 208
     282:	9e 4f       	sbci	r25, 0xFE	; 254
     284:	fc 01       	movw	r30, r24
     286:	d2 83       	std	Z+2, r29	; 0x02
     288:	c1 83       	std	Z+1, r28	; 0x01
C:\Users\táta\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\libraries\Servo_ATTinyCore\src\avr/Servo_ATTinyCore.cpp:1272
    SREG = oldSREG;
     28a:	2f bf       	out	0x3f, r18	; 63
_ZN5Servo5writeEi.constprop.4():
C:\Users\táta\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\libraries\Servo_ATTinyCore\src\avr/Servo_ATTinyCore.cpp:1253
    if(value < 0) value = 0;
    if(value > 180) value = 180;
    value = map(value, 0, 180, SERVO_MIN(),  SERVO_MAX());
  }
  this->writeMicroseconds(value);
}
     28c:	df 91       	pop	r29
     28e:	cf 91       	pop	r28
     290:	1f 91       	pop	r17
     292:	0f 91       	pop	r16
     294:	ff 90       	pop	r15
     296:	bf 90       	pop	r11
     298:	af 90       	pop	r10
     29a:	9f 90       	pop	r9
     29c:	8f 90       	pop	r8
     29e:	08 95       	ret

000002a0 <digitalRead>:
digitalRead():
C:\Users\táta\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\cores\tinymodern/wiring_digital.c:248
#endif

int digitalRead(uint8_t pin)
{
  if (pin&128) {pin=analogInputToDigitalPin((pin&127));}
  uint8_t bit = digitalPinToBitMask(pin);
     2a0:	90 e0       	ldi	r25, 0x00	; 0
     2a2:	fc 01       	movw	r30, r24
     2a4:	ee 56       	subi	r30, 0x6E	; 110
     2a6:	ff 4f       	sbci	r31, 0xFF	; 255
     2a8:	24 91       	lpm	r18, Z
C:\Users\táta\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\cores\tinymodern/wiring_digital.c:249
  uint8_t port = digitalPinToPort(pin);
     2aa:	fc 01       	movw	r30, r24
     2ac:	e0 58       	subi	r30, 0x80	; 128
     2ae:	ff 4f       	sbci	r31, 0xFF	; 255
     2b0:	e4 91       	lpm	r30, Z
C:\Users\táta\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\cores\tinymodern/wiring_digital.c:251

  if (port == NOT_A_PIN) return LOW;
     2b2:	ee 23       	and	r30, r30
     2b4:	61 f0       	breq	.+24     	; 0x2ce <digitalRead+0x2e>
C:\Users\táta\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\cores\tinymodern/wiring_digital.c:257

  // If the pin that support PWM output, we need to turn it off
  // before getting a digital reading.
  turnOffPWM( pin );

  if (*portInputRegister(port) & bit) return HIGH;
     2b6:	f0 e0       	ldi	r31, 0x00	; 0
     2b8:	e4 58       	subi	r30, 0x84	; 132
     2ba:	ff 4f       	sbci	r31, 0xFF	; 255
     2bc:	a4 91       	lpm	r26, Z
     2be:	b0 e0       	ldi	r27, 0x00	; 0
     2c0:	ec 91       	ld	r30, X
     2c2:	e2 23       	and	r30, r18
     2c4:	81 e0       	ldi	r24, 0x01	; 1
     2c6:	90 e0       	ldi	r25, 0x00	; 0
     2c8:	21 f4       	brne	.+8      	; 0x2d2 <digitalRead+0x32>
     2ca:	80 e0       	ldi	r24, 0x00	; 0
     2cc:	08 95       	ret
C:\Users\táta\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\cores\tinymodern/wiring_digital.c:251
{
  if (pin&128) {pin=analogInputToDigitalPin((pin&127));}
  uint8_t bit = digitalPinToBitMask(pin);
  uint8_t port = digitalPinToPort(pin);

  if (port == NOT_A_PIN) return LOW;
     2ce:	80 e0       	ldi	r24, 0x00	; 0
     2d0:	90 e0       	ldi	r25, 0x00	; 0
C:\Users\táta\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\cores\tinymodern/wiring_digital.c:259
  // before getting a digital reading.
  turnOffPWM( pin );

  if (*portInputRegister(port) & bit) return HIGH;
  return LOW;
}
     2d2:	08 95       	ret

000002d4 <digitalWrite>:
digitalWrite():
C:\Users\táta\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\cores\tinymodern/wiring_digital.c:181
}

#if defined(__AVR_ATtinyX41__ ) || defined(__AVR_ATtiny1634__) || defined(__AVR_ATtiny828__)

void digitalWrite(uint8_t pin, uint8_t val)
{
     2d4:	cf 93       	push	r28
     2d6:	df 93       	push	r29
C:\Users\táta\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\cores\tinymodern/wiring_digital.c:185
  #ifndef __AVR_ATtiny828__
  if (pin&64) {pin=analogInputToDigitalPin((pin&63));}
  #endif
  uint8_t bit = digitalPinToBitMask(pin);
     2d8:	a8 2f       	mov	r26, r24
     2da:	b0 e0       	ldi	r27, 0x00	; 0
     2dc:	fd 01       	movw	r30, r26
     2de:	ee 56       	subi	r30, 0x6E	; 110
     2e0:	ff 4f       	sbci	r31, 0xFF	; 255
     2e2:	24 91       	lpm	r18, Z
C:\Users\táta\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\cores\tinymodern/wiring_digital.c:186
  uint8_t port = digitalPinToPort(pin);
     2e4:	a0 58       	subi	r26, 0x80	; 128
     2e6:	bf 4f       	sbci	r27, 0xFF	; 255
     2e8:	fd 01       	movw	r30, r26
     2ea:	a4 91       	lpm	r26, Z
C:\Users\táta\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\cores\tinymodern/wiring_digital.c:189
  volatile uint8_t *out, *pue;

  if (port == NOT_A_PIN) return;
     2ec:	aa 23       	and	r26, r26
     2ee:	e9 f0       	breq	.+58     	; 0x32a <digitalWrite+0x56>
turnOffPWM():
C:\Users\táta\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\cores\tinymodern/wiring_digital.c:123
// each digitalread or write.
//
__attribute__((always_inline)) static inline void turnOffPWM( uint8_t pin )
{
  #if CORE_PWM_COUNT >= 1
    if ( pin == CORE_PWM0_PIN )
     2f0:	8d 30       	cpi	r24, 0x0D	; 13
     2f2:	f1 f4       	brne	.+60     	; 0x330 <digitalWrite+0x5c>
Timer0_SetCompareOutputModeA():
C:\Users\táta\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\cores\tinymodern/core_timers.h:692
}
timer0_com_t;

__attribute__((always_inline)) static inline void Timer0_SetCompareOutputModeA( timer0_com_t com )
{
  TCCR0A = (TCCR0A & ~MASK2(COM0A1,COM0A0)) | (com << COM0A0);
     2f4:	8b b3       	in	r24, 0x1b	; 27
     2f6:	8f 73       	andi	r24, 0x3F	; 63
Timer0_SetCompareOutputModeB():
C:\Users\táta\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\cores\tinymodern/core_timers.h:697
}

__attribute__((always_inline)) static inline void Timer0_SetCompareOutputModeB( timer0_com_t com )
{
  TCCR0A = (TCCR0A & ~MASK2(COM0B1,COM0B0)) | (com << COM0B0);
     2f8:	8b bb       	out	0x1b, r24	; 27
digitalWrite():
C:\Users\táta\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\cores\tinymodern/wiring_digital.c:195

  // If the pin that support PWM output, we need to turn it off
  // before doing a digital write.
  turnOffPWM( pin );

  out = portOutputRegister(port);
     2fa:	b0 e0       	ldi	r27, 0x00	; 0
     2fc:	fd 01       	movw	r30, r26
     2fe:	e8 58       	subi	r30, 0x88	; 136
     300:	ff 4f       	sbci	r31, 0xFF	; 255
     302:	c4 91       	lpm	r28, Z
     304:	d0 e0       	ldi	r29, 0x00	; 0
C:\Users\táta\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\cores\tinymodern/wiring_digital.c:196
  pue = portPullupRegister(port);
     306:	ac 58       	subi	r26, 0x8C	; 140
     308:	bf 4f       	sbci	r27, 0xFF	; 255
     30a:	fd 01       	movw	r30, r26
     30c:	a4 91       	lpm	r26, Z
     30e:	b0 e0       	ldi	r27, 0x00	; 0
     310:	92 2f       	mov	r25, r18
     312:	90 95       	com	r25
C:\Users\táta\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\cores\tinymodern/wiring_digital.c:198

  if (val == LOW) {
     314:	61 11       	cpse	r22, r1
     316:	1f c0       	rjmp	.+62     	; 0x356 <digitalWrite+0x82>
C:\Users\táta\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\cores\tinymodern/wiring_digital.c:199
    uint8_t oldSREG = SREG;
     318:	2f b7       	in	r18, 0x3f	; 63
C:\Users\táta\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\cores\tinymodern/wiring_digital.c:200
    cli();
     31a:	f8 94       	cli
C:\Users\táta\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\cores\tinymodern/wiring_digital.c:201
    *out &= ~bit;
     31c:	88 81       	ld	r24, Y
     31e:	89 23       	and	r24, r25
     320:	88 83       	st	Y, r24
C:\Users\táta\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\cores\tinymodern/wiring_digital.c:202
    *pue &= ~bit; //Turn off the pullups
     322:	8c 91       	ld	r24, X
     324:	89 23       	and	r24, r25
     326:	8c 93       	st	X, r24
C:\Users\táta\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\cores\tinymodern/wiring_digital.c:203
    SREG = oldSREG;
     328:	2f bf       	out	0x3f, r18	; 63
C:\Users\táta\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\cores\tinymodern/wiring_digital.c:211
    cli();
    *out |= bit;
    *pue &= ~bit;
    SREG = oldSREG;
  }
}
     32a:	df 91       	pop	r29
     32c:	cf 91       	pop	r28
     32e:	08 95       	ret
turnOffPWM():
C:\Users\táta\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\cores\tinymodern/wiring_digital.c:131
    }
    else
  #endif

  #if CORE_PWM_COUNT >= 2
    if ( pin == CORE_PWM1_PIN )
     330:	83 30       	cpi	r24, 0x03	; 3
     332:	19 f4       	brne	.+6      	; 0x33a <digitalWrite+0x66>
Timer0_SetCompareOutputModeB():
C:\Users\táta\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\cores\tinymodern/core_timers.h:697
     334:	8b b3       	in	r24, 0x1b	; 27
     336:	8f 7c       	andi	r24, 0xCF	; 207
     338:	df cf       	rjmp	.-66     	; 0x2f8 <digitalWrite+0x24>
turnOffPWM():
C:\Users\táta\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\cores\tinymodern/wiring_digital.c:139
    }
    else
  #endif

  #if CORE_PWM_COUNT >= 3
    if ( pin == CORE_PWM2_PIN )
     33a:	8e 30       	cpi	r24, 0x0E	; 14
     33c:	31 f4       	brne	.+12     	; 0x34a <digitalWrite+0x76>
Timer1_SetCompareOutputModeA():
C:\Users\táta\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\cores\tinymodern/core_timers.h:852
}
timer1_com_t;

__attribute__((always_inline)) static inline void Timer1_SetCompareOutputModeA( timer1_com_t com )
{
  TCCR1A = (TCCR1A & ~MASK2(COM1A1,COM1A0)) | (com << COM1A0);
     33e:	80 91 72 00 	lds	r24, 0x0072	; 0x800072 <__EEPROM_REGION_LENGTH__+0x7f0072>
     342:	8f 73       	andi	r24, 0x3F	; 63
Timer1_SetCompareOutputModeB():
C:\Users\táta\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\cores\tinymodern/core_timers.h:857
}

__attribute__((always_inline)) static inline void Timer1_SetCompareOutputModeB( timer1_com_t com )
{
  TCCR1A = (TCCR1A & ~MASK2(COM1B1,COM1B0)) | (com << COM1B0);
     344:	80 93 72 00 	sts	0x0072, r24	; 0x800072 <__EEPROM_REGION_LENGTH__+0x7f0072>
     348:	d8 cf       	rjmp	.-80     	; 0x2fa <digitalWrite+0x26>
turnOffPWM():
C:\Users\táta\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\cores\tinymodern/wiring_digital.c:147
    }
    else
  #endif

  #if CORE_PWM_COUNT >= 4
    if ( pin == CORE_PWM3_PIN )
     34a:	82 30       	cpi	r24, 0x02	; 2
     34c:	b1 f6       	brne	.-84     	; 0x2fa <digitalWrite+0x26>
Timer1_SetCompareOutputModeB():
C:\Users\táta\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\cores\tinymodern/core_timers.h:857
     34e:	80 91 72 00 	lds	r24, 0x0072	; 0x800072 <__EEPROM_REGION_LENGTH__+0x7f0072>
     352:	8f 7c       	andi	r24, 0xCF	; 207
     354:	f7 cf       	rjmp	.-18     	; 0x344 <digitalWrite+0x70>
digitalWrite():
C:\Users\táta\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\cores\tinymodern/wiring_digital.c:205
    cli();
    *out &= ~bit;
    *pue &= ~bit; //Turn off the pullups
    SREG = oldSREG;
  } else {
    uint8_t oldSREG = SREG;
     356:	3f b7       	in	r19, 0x3f	; 63
C:\Users\táta\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\cores\tinymodern/wiring_digital.c:206
    cli();
     358:	f8 94       	cli
C:\Users\táta\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\cores\tinymodern/wiring_digital.c:207
    *out |= bit;
     35a:	e8 81       	ld	r30, Y
     35c:	e2 2b       	or	r30, r18
     35e:	e8 83       	st	Y, r30
C:\Users\táta\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\cores\tinymodern/wiring_digital.c:208
    *pue &= ~bit;
     360:	8c 91       	ld	r24, X
     362:	89 23       	and	r24, r25
     364:	8c 93       	st	X, r24
C:\Users\táta\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\cores\tinymodern/wiring_digital.c:209
    SREG = oldSREG;
     366:	3f bf       	out	0x3f, r19	; 63
     368:	e0 cf       	rjmp	.-64     	; 0x32a <digitalWrite+0x56>

0000036a <pinMode>:
pinMode():
C:\Users\táta\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\cores\tinymodern/wiring_digital.c:37
#include "core_timers.h"
#include "PwmTimer.h"

#if defined(__AVR_ATtinyX41__ ) || defined(__AVR_ATtiny1634__) || defined(__AVR_ATtiny828__)
void pinMode(uint8_t pin, uint8_t mode)
{
     36a:	cf 93       	push	r28
     36c:	df 93       	push	r29
C:\Users\táta\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\cores\tinymodern/wiring_digital.c:39
  #ifndef __AVR_ATtiny828__
  if (pin&64) {pin=analogInputToDigitalPin((pin & 63));}
     36e:	86 ff       	sbrs	r24, 6
     370:	07 c0       	rjmp	.+14     	; 0x380 <pinMode+0x16>
     372:	8f 73       	andi	r24, 0x3F	; 63
     374:	a5 e0       	ldi	r26, 0x05	; 5
     376:	86 30       	cpi	r24, 0x06	; 6
     378:	08 f0       	brcs	.+2      	; 0x37c <pinMode+0x12>
     37a:	a6 e1       	ldi	r26, 0x16	; 22
     37c:	a8 1b       	sub	r26, r24
     37e:	8a 2f       	mov	r24, r26
C:\Users\táta\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\cores\tinymodern/wiring_digital.c:41
  #endif
  uint8_t bit = digitalPinToBitMask(pin);
     380:	a8 2f       	mov	r26, r24
     382:	b0 e0       	ldi	r27, 0x00	; 0
     384:	fd 01       	movw	r30, r26
     386:	ee 56       	subi	r30, 0x6E	; 110
     388:	ff 4f       	sbci	r31, 0xFF	; 255
     38a:	24 91       	lpm	r18, Z
C:\Users\táta\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\cores\tinymodern/wiring_digital.c:42
  uint8_t port = digitalPinToPort(pin);
     38c:	a0 58       	subi	r26, 0x80	; 128
     38e:	bf 4f       	sbci	r27, 0xFF	; 255
     390:	fd 01       	movw	r30, r26
     392:	a4 91       	lpm	r26, Z
C:\Users\táta\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\cores\tinymodern/wiring_digital.c:45
  volatile uint8_t *reg, *out, *pue;

  if (port == NOT_A_PIN) return;
     394:	aa 23       	and	r26, r26
     396:	19 f1       	breq	.+70     	; 0x3de <pinMode+0x74>
C:\Users\táta\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\cores\tinymodern/wiring_digital.c:48

  // JWS: can I let the optimizer do this?
  reg = portModeRegister(port);
     398:	b0 e0       	ldi	r27, 0x00	; 0
     39a:	fd 01       	movw	r30, r26
     39c:	e0 59       	subi	r30, 0x90	; 144
     39e:	ff 4f       	sbci	r31, 0xFF	; 255
     3a0:	e4 91       	lpm	r30, Z
     3a2:	ce 2f       	mov	r28, r30
     3a4:	d0 e0       	ldi	r29, 0x00	; 0
C:\Users\táta\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\cores\tinymodern/wiring_digital.c:49
  out = portOutputRegister(port);
     3a6:	fd 01       	movw	r30, r26
     3a8:	e8 58       	subi	r30, 0x88	; 136
     3aa:	ff 4f       	sbci	r31, 0xFF	; 255
     3ac:	e4 91       	lpm	r30, Z
     3ae:	8e 2f       	mov	r24, r30
     3b0:	90 e0       	ldi	r25, 0x00	; 0
C:\Users\táta\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\cores\tinymodern/wiring_digital.c:50
  pue = portPullupRegister(port);
     3b2:	ac 58       	subi	r26, 0x8C	; 140
     3b4:	bf 4f       	sbci	r27, 0xFF	; 255
     3b6:	fd 01       	movw	r30, r26
     3b8:	a4 91       	lpm	r26, Z
     3ba:	b0 e0       	ldi	r27, 0x00	; 0
     3bc:	32 2f       	mov	r19, r18
     3be:	30 95       	com	r19
C:\Users\táta\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\cores\tinymodern/wiring_digital.c:52

  if (mode == INPUT) {
     3c0:	61 11       	cpse	r22, r1
     3c2:	10 c0       	rjmp	.+32     	; 0x3e4 <pinMode+0x7a>
C:\Users\táta\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\cores\tinymodern/wiring_digital.c:53
    uint8_t oldSREG = SREG;
     3c4:	4f b7       	in	r20, 0x3f	; 63
C:\Users\táta\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\cores\tinymodern/wiring_digital.c:54
                cli();
     3c6:	f8 94       	cli
C:\Users\táta\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\cores\tinymodern/wiring_digital.c:55
    *reg &= ~bit;
     3c8:	28 81       	ld	r18, Y
     3ca:	23 23       	and	r18, r19
     3cc:	28 83       	st	Y, r18
C:\Users\táta\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\cores\tinymodern/wiring_digital.c:56
    *out &= ~bit;
     3ce:	fc 01       	movw	r30, r24
     3d0:	20 81       	ld	r18, Z
     3d2:	23 23       	and	r18, r19
     3d4:	20 83       	st	Z, r18
C:\Users\táta\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\cores\tinymodern/wiring_digital.c:57
    *pue &= ~bit;
     3d6:	8c 91       	ld	r24, X
     3d8:	38 23       	and	r19, r24
     3da:	3c 93       	st	X, r19
C:\Users\táta\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\cores\tinymodern/wiring_digital.c:58
    SREG = oldSREG;
     3dc:	4f bf       	out	0x3f, r20	; 63
C:\Users\táta\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\cores\tinymodern/wiring_digital.c:73
                cli();
    *pue &= ~bit;
    *reg |= bit;
    SREG = oldSREG;
  }
}
     3de:	df 91       	pop	r29
     3e0:	cf 91       	pop	r28
     3e2:	08 95       	ret
C:\Users\táta\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\cores\tinymodern/wiring_digital.c:59
                cli();
    *reg &= ~bit;
    *out &= ~bit;
    *pue &= ~bit;
    SREG = oldSREG;
  } else if (mode == INPUT_PULLUP) {
     3e4:	62 30       	cpi	r22, 0x02	; 2
     3e6:	71 f4       	brne	.+28     	; 0x404 <__LOCK_REGION_LENGTH__+0x4>
C:\Users\táta\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\cores\tinymodern/wiring_digital.c:60
    uint8_t oldSREG = SREG;
     3e8:	5f b7       	in	r21, 0x3f	; 63
C:\Users\táta\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\cores\tinymodern/wiring_digital.c:61
                cli();
     3ea:	f8 94       	cli
C:\Users\táta\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\cores\tinymodern/wiring_digital.c:62
    *reg &= ~bit;
     3ec:	48 81       	ld	r20, Y
     3ee:	34 23       	and	r19, r20
     3f0:	38 83       	st	Y, r19
C:\Users\táta\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\cores\tinymodern/wiring_digital.c:63
    *out |= bit;
     3f2:	fc 01       	movw	r30, r24
     3f4:	30 81       	ld	r19, Z
     3f6:	32 2b       	or	r19, r18
     3f8:	30 83       	st	Z, r19
C:\Users\táta\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\cores\tinymodern/wiring_digital.c:64
    *pue |= bit;
     3fa:	ec 91       	ld	r30, X
     3fc:	2e 2b       	or	r18, r30
     3fe:	2c 93       	st	X, r18
C:\Users\táta\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\cores\tinymodern/wiring_digital.c:65
    SREG = oldSREG;
     400:	5f bf       	out	0x3f, r21	; 63
     402:	ed cf       	rjmp	.-38     	; 0x3de <pinMode+0x74>
C:\Users\táta\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\cores\tinymodern/wiring_digital.c:67
  } else {
    uint8_t oldSREG = SREG;
     404:	9f b7       	in	r25, 0x3f	; 63
C:\Users\táta\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\cores\tinymodern/wiring_digital.c:68
                cli();
     406:	f8 94       	cli
C:\Users\táta\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\cores\tinymodern/wiring_digital.c:69
    *pue &= ~bit;
     408:	8c 91       	ld	r24, X
     40a:	38 23       	and	r19, r24
     40c:	3c 93       	st	X, r19
C:\Users\táta\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\cores\tinymodern/wiring_digital.c:70
    *reg |= bit;
     40e:	e8 81       	ld	r30, Y
     410:	2e 2b       	or	r18, r30
     412:	28 83       	st	Y, r18
C:\Users\táta\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\cores\tinymodern/wiring_digital.c:71
    SREG = oldSREG;
     414:	9f bf       	out	0x3f, r25	; 63
     416:	e3 cf       	rjmp	.-58     	; 0x3de <pinMode+0x74>

00000418 <Servo::attach(int) [clone .constprop.2]>:
_ZN5Servo6attachEi.constprop.2():
C:\Users\táta\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\libraries\Servo_ATTinyCore\src\avr/Servo_ATTinyCore.cpp:1220
  return this->attach(pin, MIN_PULSE_WIDTH, MAX_PULSE_WIDTH);
}

uint8_t Servo::attach(int pin, int min, int max)
{
  if(this->servoIndex < MAX_SERVOS ) {
     418:	80 91 54 01 	lds	r24, 0x0154	; 0x800154 <servo>
     41c:	8c 30       	cpi	r24, 0x0C	; 12
     41e:	08 f0       	brcs	.+2      	; 0x422 <Servo::attach(int) [clone .constprop.2]+0xa>
     420:	54 c0       	rjmp	.+168    	; 0x4ca <Servo::attach(int) [clone .constprop.2]+0xb2>
C:\Users\táta\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\libraries\Servo_ATTinyCore\src\avr/Servo_ATTinyCore.cpp:1221
    pinMode( pin, OUTPUT) ;                                   // set servo pin to output
     422:	61 e0       	ldi	r22, 0x01	; 1
     424:	83 e0       	ldi	r24, 0x03	; 3
     426:	0e 94 b5 01 	call	0x36a	; 0x36a <pinMode>
C:\Users\táta\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\libraries\Servo_ATTinyCore\src\avr/Servo_ATTinyCore.cpp:1222
    servos[this->servoIndex].Pin.nbr = pin;
     42a:	20 91 54 01 	lds	r18, 0x0154	; 0x800154 <servo>
     42e:	82 2f       	mov	r24, r18
     430:	90 e0       	ldi	r25, 0x00	; 0
     432:	63 e0       	ldi	r22, 0x03	; 3
     434:	70 e0       	ldi	r23, 0x00	; 0
     436:	0e 94 e1 07 	call	0xfc2	; 0xfc2 <__mulhi3>
     43a:	fc 01       	movw	r30, r24
     43c:	e0 5d       	subi	r30, 0xD0	; 208
     43e:	fe 4f       	sbci	r31, 0xFE	; 254
     440:	90 81       	ld	r25, Z
     442:	90 7c       	andi	r25, 0xC0	; 192
     444:	93 60       	ori	r25, 0x03	; 3
     446:	90 83       	st	Z, r25
C:\Users\táta\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\libraries\Servo_ATTinyCore\src\avr/Servo_ATTinyCore.cpp:1224
    // todo min/max check: abs(min - MIN_PULSE_WIDTH) /4 < 128
    this->min  = (MIN_PULSE_WIDTH - min)/4; //resolution of min/max is 4 uS
     448:	10 92 55 01 	sts	0x0155, r1	; 0x800155 <servo+0x1>
C:\Users\táta\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\libraries\Servo_ATTinyCore\src\avr/Servo_ATTinyCore.cpp:1225
    this->max  = (MAX_PULSE_WIDTH - max)/4;
     44c:	10 92 56 01 	sts	0x0156, r1	; 0x800156 <servo+0x2>
C:\Users\táta\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\libraries\Servo_ATTinyCore\src\avr/Servo_ATTinyCore.cpp:1227
    // initialize the timer if it has not already been initialized
    timer16_Sequence_t timer = SERVO_INDEX_TO_TIMER(servoIndex);
     450:	82 2f       	mov	r24, r18
     452:	6c e0       	ldi	r22, 0x0C	; 12
     454:	0e 94 f2 07 	call	0xfe4	; 0xfe4 <__udivmodqi4>
     458:	48 2f       	mov	r20, r24
isTimerActive():
C:\Users\táta\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\libraries\Servo_ATTinyCore\src\avr/Servo_ATTinyCore.cpp:1194

static boolean isTimerActive(timer16_Sequence_t timer)
{
  // returns true if any servo is active on this timer
  for(uint8_t channel=0; channel < SERVOS_PER_TIMER; channel++) {
    if(SERVO(timer,channel).Pin.isActive == true)
     45a:	90 e0       	ldi	r25, 0x00	; 0
     45c:	6c e0       	ldi	r22, 0x0C	; 12
     45e:	70 e0       	ldi	r23, 0x00	; 0
     460:	0e 94 e1 07 	call	0xfc2	; 0xfc2 <__mulhi3>
     464:	fc 01       	movw	r30, r24
     466:	30 e0       	ldi	r19, 0x00	; 0
     468:	20 e0       	ldi	r18, 0x00	; 0
     46a:	cf 01       	movw	r24, r30
     46c:	82 0f       	add	r24, r18
     46e:	93 1f       	adc	r25, r19
     470:	63 e0       	ldi	r22, 0x03	; 3
     472:	70 e0       	ldi	r23, 0x00	; 0
     474:	0e 94 e1 07 	call	0xfc2	; 0xfc2 <__mulhi3>
     478:	80 5d       	subi	r24, 0xD0	; 208
     47a:	9e 4f       	sbci	r25, 0xFE	; 254
     47c:	dc 01       	movw	r26, r24
     47e:	8c 91       	ld	r24, X
     480:	86 fd       	sbrc	r24, 6
     482:	16 c0       	rjmp	.+44     	; 0x4b0 <Servo::attach(int) [clone .constprop.2]+0x98>
     484:	2f 5f       	subi	r18, 0xFF	; 255
     486:	3f 4f       	sbci	r19, 0xFF	; 255
C:\Users\táta\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\libraries\Servo_ATTinyCore\src\avr/Servo_ATTinyCore.cpp:1193
}

static boolean isTimerActive(timer16_Sequence_t timer)
{
  // returns true if any servo is active on this timer
  for(uint8_t channel=0; channel < SERVOS_PER_TIMER; channel++) {
     488:	2c 30       	cpi	r18, 0x0C	; 12
     48a:	31 05       	cpc	r19, r1
     48c:	71 f7       	brne	.-36     	; 0x46a <Servo::attach(int) [clone .constprop.2]+0x52>
initISR():
C:\Users\táta\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\libraries\Servo_ATTinyCore\src\avr/Servo_ATTinyCore.cpp:1108


static void initISR(timer16_Sequence_t timer)
{
#if defined (_useTimer1)
  if(timer == _timer1) {
     48e:	41 11       	cpse	r20, r1
     490:	0f c0       	rjmp	.+30     	; 0x4b0 <Servo::attach(int) [clone .constprop.2]+0x98>
C:\Users\táta\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\libraries\Servo_ATTinyCore\src\avr/Servo_ATTinyCore.cpp:1109
    TCCR1A = 0;             // normal counting mode
     492:	10 92 72 00 	sts	0x0072, r1	; 0x800072 <__EEPROM_REGION_LENGTH__+0x7f0072>
C:\Users\táta\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\libraries\Servo_ATTinyCore\src\avr/Servo_ATTinyCore.cpp:1110
    TCCR1B = _BV(CS11);     // set prescaler of 8
     496:	82 e0       	ldi	r24, 0x02	; 2
     498:	80 93 71 00 	sts	0x0071, r24	; 0x800071 <__EEPROM_REGION_LENGTH__+0x7f0071>
C:\Users\táta\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\libraries\Servo_ATTinyCore\src\avr/Servo_ATTinyCore.cpp:1111
    TCNT1 = 0;              // clear the timer count
     49c:	10 92 6f 00 	sts	0x006F, r1	; 0x80006f <__EEPROM_REGION_LENGTH__+0x7f006f>
     4a0:	10 92 6e 00 	sts	0x006E, r1	; 0x80006e <__EEPROM_REGION_LENGTH__+0x7f006e>
C:\Users\táta\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\libraries\Servo_ATTinyCore\src\avr/Servo_ATTinyCore.cpp:1113
#if defined(__AVR_ATmega8__)|| defined(__AVR_ATmega128__) || defined(__AVR_ATtiny1634__)
    TIFR |= _BV(OCF1A);      // clear any pending interrupts;
     4a4:	89 b7       	in	r24, 0x39	; 57
     4a6:	80 64       	ori	r24, 0x40	; 64
     4a8:	89 bf       	out	0x39, r24	; 57
C:\Users\táta\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\libraries\Servo_ATTinyCore\src\avr/Servo_ATTinyCore.cpp:1114
    TIMSK |=  _BV(OCIE1A) ;  // enable the output compare interrupt
     4aa:	8a b7       	in	r24, 0x3a	; 58
     4ac:	80 64       	ori	r24, 0x40	; 64
     4ae:	8a bf       	out	0x3a, r24	; 58
_ZN5Servo6attachEi.constprop.2():
C:\Users\táta\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\libraries\Servo_ATTinyCore\src\avr/Servo_ATTinyCore.cpp:1230
    this->max  = (MAX_PULSE_WIDTH - max)/4;
    // initialize the timer if it has not already been initialized
    timer16_Sequence_t timer = SERVO_INDEX_TO_TIMER(servoIndex);
    if(isTimerActive(timer) == false)
      initISR(timer);
    servos[this->servoIndex].Pin.isActive = true;  // this must be set after the check for isTimerActive
     4b0:	80 91 54 01 	lds	r24, 0x0154	; 0x800154 <servo>
     4b4:	90 e0       	ldi	r25, 0x00	; 0
     4b6:	63 e0       	ldi	r22, 0x03	; 3
     4b8:	70 e0       	ldi	r23, 0x00	; 0
     4ba:	0e 94 e1 07 	call	0xfc2	; 0xfc2 <__mulhi3>
     4be:	fc 01       	movw	r30, r24
     4c0:	e0 5d       	subi	r30, 0xD0	; 208
     4c2:	fe 4f       	sbci	r31, 0xFE	; 254
     4c4:	80 81       	ld	r24, Z
     4c6:	80 64       	ori	r24, 0x40	; 64
     4c8:	80 83       	st	Z, r24
C:\Users\táta\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\libraries\Servo_ATTinyCore\src\avr/Servo_ATTinyCore.cpp:1215
    this->servoIndex = INVALID_SERVO ;  // too many servos
}

uint8_t Servo::attach(int pin)
{
  return this->attach(pin, MIN_PULSE_WIDTH, MAX_PULSE_WIDTH);
     4ca:	80 91 54 01 	lds	r24, 0x0154	; 0x800154 <servo>
C:\Users\táta\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\libraries\Servo_ATTinyCore\src\avr/Servo_ATTinyCore.cpp:1216
}
     4ce:	08 95       	ret

000004d0 <micros>:
micros():
C:\Users\táta\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\cores\tinymodern/wiring.c:130
  return m;
}
unsigned long micros()
{
  unsigned long m;
  uint8_t oldSREG = SREG, t;
     4d0:	3f b7       	in	r19, 0x3f	; 63
C:\Users\táta\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\cores\tinymodern/wiring.c:132

  cli();
     4d2:	f8 94       	cli
C:\Users\táta\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\cores\tinymodern/wiring.c:133
  m = millis_timer_overflow_count;
     4d4:	80 91 28 01 	lds	r24, 0x0128	; 0x800128 <millis_timer_overflow_count>
     4d8:	90 91 29 01 	lds	r25, 0x0129	; 0x800129 <millis_timer_overflow_count+0x1>
     4dc:	a0 91 2a 01 	lds	r26, 0x012A	; 0x80012a <millis_timer_overflow_count+0x2>
     4e0:	b0 91 2b 01 	lds	r27, 0x012B	; 0x80012b <millis_timer_overflow_count+0x3>
C:\Users\táta\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\cores\tinymodern/wiring.c:135
#if defined(TCNT0) && (TIMER_TO_USE_FOR_MILLIS == 0) && !defined(TCW0)
  t = TCNT0;
     4e4:	29 b3       	in	r18, 0x19	; 25
C:\Users\táta\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\cores\tinymodern/wiring.c:150

#if defined(TIFR0) && (TIMER_TO_USE_FOR_MILLIS == 0)
  if ((TIFR0 & _BV(TOV0)) && (t < 255))
    m++;
#elif defined(TIFR) && (TIMER_TO_USE_FOR_MILLIS == 0)
  if ((TIFR & _BV(TOV0)) && (t < 255))
     4e6:	09 b6       	in	r0, 0x39	; 57
     4e8:	01 fe       	sbrs	r0, 1
     4ea:	05 c0       	rjmp	.+10     	; 0x4f6 <micros+0x26>
     4ec:	2f 3f       	cpi	r18, 0xFF	; 255
     4ee:	19 f0       	breq	.+6      	; 0x4f6 <micros+0x26>
C:\Users\táta\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\cores\tinymodern/wiring.c:151
    m++;
     4f0:	01 96       	adiw	r24, 0x01	; 1
     4f2:	a1 1d       	adc	r26, r1
     4f4:	b1 1d       	adc	r27, r1
C:\Users\táta\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\cores\tinymodern/wiring.c:160
#elif defined(TIFR) && (TIMER_TO_USE_FOR_MILLIS == 1)
  if ((TIFR & _BV(TOV1)) && (t < 255))
    m++;
#endif

  SREG = oldSREG;
     4f6:	3f bf       	out	0x3f, r19	; 63
C:\Users\táta\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\cores\tinymodern/wiring.c:167

#if F_CPU < 1000000L
  return ((m << 8) + t) * MillisTimer_Prescale_Value * (1000000L/F_CPU);
#else
#if (MillisTimer_Prescale_Value % clockCyclesPerMicrosecond() == 0 ) // Can we just do it the naive way? If so great!
  return ((m << 8) + t) * (MillisTimer_Prescale_Value / clockCyclesPerMicrosecond());
     4f8:	ba 2f       	mov	r27, r26
     4fa:	a9 2f       	mov	r26, r25
     4fc:	98 2f       	mov	r25, r24
     4fe:	88 27       	eor	r24, r24
     500:	bc 01       	movw	r22, r24
     502:	cd 01       	movw	r24, r26
     504:	62 0f       	add	r22, r18
     506:	71 1d       	adc	r23, r1
     508:	81 1d       	adc	r24, r1
     50a:	91 1d       	adc	r25, r1
     50c:	43 e0       	ldi	r20, 0x03	; 3
     50e:	66 0f       	add	r22, r22
     510:	77 1f       	adc	r23, r23
     512:	88 1f       	adc	r24, r24
     514:	99 1f       	adc	r25, r25
     516:	4a 95       	dec	r20
     518:	d1 f7       	brne	.-12     	; 0x50e <__stack+0xf>
C:\Users\táta\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\cores\tinymodern/wiring.c:210
  //the high part gets divided by cCPuS then multiplied by the prescaler. Then take the low 8 bits plus the high part modulo-cCPuS to correct for the division, then multiply that by the prescaler value first before dividing by cCPuS, and finally add the two together.
  //return ((m << 8 )/clockCyclesPerMicrosecond()* MillisTimer_Prescale_Value) + ((t+(((m<<8)%clockCyclesPerMicrosecond())) * MillisTimer_Prescale_Value / clockCyclesPerMicrosecond()));
  return ((m << 8 )/clockCyclesPerMicrosecond()* MillisTimer_Prescale_Value) + (t * MillisTimer_Prescale_Value / clockCyclesPerMicrosecond());
#endif
#endif
}
     51a:	08 95       	ret

0000051c <delay>:
delay():
C:\Users\táta\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\cores\tinymodern/wiring.c:218
  // Empty
}
void yield(void) __attribute__ ((weak, alias("__empty")));

void delay(unsigned long ms)
{
     51c:	cf 92       	push	r12
     51e:	df 92       	push	r13
     520:	ef 92       	push	r14
     522:	ff 92       	push	r15
     524:	cf 93       	push	r28
     526:	df 93       	push	r29
     528:	6b 01       	movw	r12, r22
     52a:	7c 01       	movw	r14, r24
C:\Users\táta\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\cores\tinymodern/wiring.c:220
  #if (F_CPU>=1000000L)
  uint16_t start = (uint16_t)micros();
     52c:	0e 94 68 02 	call	0x4d0	; 0x4d0 <micros>
     530:	eb 01       	movw	r28, r22
C:\Users\táta\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\cores\tinymodern/wiring.c:224

  while (ms > 0) {
    yield();
    while (((uint16_t)micros() - start) >= 1000 && ms) {
     532:	0e 94 68 02 	call	0x4d0	; 0x4d0 <micros>
     536:	6c 1b       	sub	r22, r28
     538:	7d 0b       	sbc	r23, r29
     53a:	68 3e       	cpi	r22, 0xE8	; 232
     53c:	73 40       	sbci	r23, 0x03	; 3
     53e:	a0 f0       	brcs	.+40     	; 0x568 <delay+0x4c>
     540:	c1 14       	cp	r12, r1
     542:	d1 04       	cpc	r13, r1
     544:	e1 04       	cpc	r14, r1
     546:	f1 04       	cpc	r15, r1
     548:	39 f4       	brne	.+14     	; 0x558 <delay+0x3c>
C:\Users\táta\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\cores\tinymodern/wiring.c:234
  #else
  uint32_t start = millis();
  while((millis() - start) < ms)  /* NOP */yield();
  return;
  #endif
}
     54a:	df 91       	pop	r29
     54c:	cf 91       	pop	r28
     54e:	ff 90       	pop	r15
     550:	ef 90       	pop	r14
     552:	df 90       	pop	r13
     554:	cf 90       	pop	r12
     556:	08 95       	ret
C:\Users\táta\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\cores\tinymodern/wiring.c:225
  uint16_t start = (uint16_t)micros();

  while (ms > 0) {
    yield();
    while (((uint16_t)micros() - start) >= 1000 && ms) {
      ms--;
     558:	81 e0       	ldi	r24, 0x01	; 1
     55a:	c8 1a       	sub	r12, r24
     55c:	d1 08       	sbc	r13, r1
     55e:	e1 08       	sbc	r14, r1
     560:	f1 08       	sbc	r15, r1
C:\Users\táta\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\cores\tinymodern/wiring.c:226
      start += 1000;
     562:	c8 51       	subi	r28, 0x18	; 24
     564:	dc 4f       	sbci	r29, 0xFC	; 252
     566:	e5 cf       	rjmp	.-54     	; 0x532 <delay+0x16>
C:\Users\táta\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\cores\tinymodern/wiring.c:222
void delay(unsigned long ms)
{
  #if (F_CPU>=1000000L)
  uint16_t start = (uint16_t)micros();

  while (ms > 0) {
     568:	c1 14       	cp	r12, r1
     56a:	d1 04       	cpc	r13, r1
     56c:	e1 04       	cpc	r14, r1
     56e:	f1 04       	cpc	r15, r1
     570:	01 f7       	brne	.-64     	; 0x532 <delay+0x16>
     572:	eb cf       	rjmp	.-42     	; 0x54a <delay+0x2e>

00000574 <USI_TWI_Master_Transfer>:
USI_TWI_Master_Transfer():
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/USI_TWI_Master.c:226
 Data to be sent has to be placed into the USIDR prior to calling
 this function. Data read, will be return'ed from the function.
---------------------------------------------------------------*/
unsigned char USI_TWI_Master_Transfer(unsigned char temp)
{
  USISR = temp;                                          // Set USISR according to temp.
     574:	8b bd       	out	0x2b, r24	; 43
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/USI_TWI_Master.c:234
         (1 << USIWM1) | (0 << USIWM0) |                 // Set USI in Two-wire mode.
         (1 << USICS1) | (0 << USICS0) | (1 << USICLK) | // Software clock strobe as source.
         (1 << USITC);                                   // Toggle Clock Port.
  do {
    DELAY_T2TWI;
    USICR = temp; // Generate positive SCL edge.
     576:	8b e2       	ldi	r24, 0x2B	; 43
_delay_us():
c:\users\táta\appdata\local\arduino15\packages\arduino\tools\avr-gcc\7.3.0-atmel3.6.1-arduino5\avr\include\util/delay.h:276
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     578:	9e e0       	ldi	r25, 0x0E	; 14
     57a:	9a 95       	dec	r25
     57c:	f1 f7       	brne	.-4      	; 0x57a <USI_TWI_Master_Transfer+0x6>
USI_TWI_Master_Transfer():
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/USI_TWI_Master.c:234
     57e:	8a bd       	out	0x2a, r24	; 42
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/USI_TWI_Master.c:235
    while (!(PIN_USI_CL & (1 << PIN_USI_SCL)))
     580:	39 9b       	sbis	0x07, 1	; 7
     582:	fe cf       	rjmp	.-4      	; 0x580 <USI_TWI_Master_Transfer+0xc>
_delay_us():
c:\users\táta\appdata\local\arduino15\packages\arduino\tools\avr-gcc\7.3.0-atmel3.6.1-arduino5\avr\include\util/delay.h:276
     584:	96 e0       	ldi	r25, 0x06	; 6
     586:	9a 95       	dec	r25
     588:	f1 f7       	brne	.-4      	; 0x586 <USI_TWI_Master_Transfer+0x12>
     58a:	00 c0       	rjmp	.+0      	; 0x58c <USI_TWI_Master_Transfer+0x18>
USI_TWI_Master_Transfer():
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/USI_TWI_Master.c:238
      ; // Wait for SCL to go high.
    DELAY_T4TWI;
    USICR = temp;                   // Generate negative SCL edge.
     58c:	8a bd       	out	0x2a, r24	; 42
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/USI_TWI_Master.c:239
  } while (!(USISR & (1 << USIOIF))); // Check for transfer complete.
     58e:	0b b4       	in	r0, 0x2b	; 43
     590:	06 fe       	sbrs	r0, 6
     592:	f2 cf       	rjmp	.-28     	; 0x578 <USI_TWI_Master_Transfer+0x4>
_delay_us():
c:\users\táta\appdata\local\arduino15\packages\arduino\tools\avr-gcc\7.3.0-atmel3.6.1-arduino5\avr\include\util/delay.h:276
     594:	8e e0       	ldi	r24, 0x0E	; 14
     596:	8a 95       	dec	r24
     598:	f1 f7       	brne	.-4      	; 0x596 <USI_TWI_Master_Transfer+0x22>
USI_TWI_Master_Transfer():
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/USI_TWI_Master.c:242

  DELAY_T2TWI;
  temp  = USIDR;                 // Read out data.
     59a:	8c b5       	in	r24, 0x2c	; 44
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/USI_TWI_Master.c:243
  USIDR = 0xFF;                  // Release SDA.
     59c:	9f ef       	ldi	r25, 0xFF	; 255
     59e:	9c bd       	out	0x2c, r25	; 44
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/USI_TWI_Master.c:244
  DDR_USI |= (1 << PIN_USI_SDA); // Enable SDA as output.
     5a0:	61 9a       	sbi	0x0c, 1	; 12
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/USI_TWI_Master.c:247

  return temp; // Return the data from the USIDR
}
     5a2:	08 95       	ret

000005a4 <USI_TWI_Start_Transceiver_With_Data_Stop>:
USI_TWI_Start_Transceiver_With_Data_Stop():
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/USI_TWI_Master.c:106
#ifndef __GNUC__
__x // AVR compiler
#endif
    unsigned char
    USI_TWI_Start_Transceiver_With_Data_Stop(unsigned char *msg, unsigned char msgSize, unsigned char stop)
{
     5a4:	ff 92       	push	r15
     5a6:	0f 93       	push	r16
     5a8:	1f 93       	push	r17
     5aa:	cf 93       	push	r28
     5ac:	df 93       	push	r29
     5ae:	06 2f       	mov	r16, r22
     5b0:	14 2f       	mov	r17, r20
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/USI_TWI_Master.c:115
  unsigned char tempUSISR_1bit = (1 << USISIF) | (1 << USIOIF) | (1 << USIPF) | (1 << USIDC)
                                 |                 // Prepare register value to: Clear flags, and
                                 (0xE << USICNT0); // set USI to shift 1 bit i.e. count 2 clock edges.

  USI_TWI_state.errorState  = 0;
  USI_TWI_state.addressMode = TRUE;
     5b2:	21 e0       	ldi	r18, 0x01	; 1
     5b4:	20 93 5f 01 	sts	0x015F, r18	; 0x80015f <USI_TWI_state>
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/USI_TWI_Master.c:145
    USI_TWI_state.errorState = USI_TWI_UE_DATA_COL;
    return (FALSE);
  }
#endif

  if (!(*msg
     5b8:	fc 01       	movw	r30, r24
     5ba:	20 81       	ld	r18, Z
     5bc:	20 fd       	sbrc	r18, 0
     5be:	03 c0       	rjmp	.+6      	; 0x5c6 <USI_TWI_Start_Transceiver_With_Data_Stop+0x22>
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/USI_TWI_Master.c:148
        & (1 << TWI_READ_BIT))) // The LSB in the address byte determines if is a masterRead or masterWrite operation.
  {
    USI_TWI_state.masterWriteDataMode = TRUE;
     5c0:	23 e0       	ldi	r18, 0x03	; 3
     5c2:	20 93 5f 01 	sts	0x015F, r18	; 0x80015f <USI_TWI_state>
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/USI_TWI_Master.c:152
  }

  /* Release SCL to ensure that (repeated) Start can be performed */
  PORT_USI_CL |= (1 << PIN_USI_SCL); // Release SCL.
     5c6:	49 9a       	sbi	0x09, 1	; 9
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/USI_TWI_Master.c:153
  while (!(PIN_USI_CL & (1 << PIN_USI_SCL)))
     5c8:	39 9b       	sbis	0x07, 1	; 7
     5ca:	fe cf       	rjmp	.-4      	; 0x5c8 <USI_TWI_Start_Transceiver_With_Data_Stop+0x24>
_delay_us():
c:\users\táta\appdata\local\arduino15\packages\arduino\tools\avr-gcc\7.3.0-atmel3.6.1-arduino5\avr\include\util/delay.h:276
     5cc:	f6 e0       	ldi	r31, 0x06	; 6
     5ce:	fa 95       	dec	r31
     5d0:	f1 f7       	brne	.-4      	; 0x5ce <USI_TWI_Start_Transceiver_With_Data_Stop+0x2a>
     5d2:	00 c0       	rjmp	.+0      	; 0x5d4 <USI_TWI_Start_Transceiver_With_Data_Stop+0x30>
USI_TWI_Start_Transceiver_With_Data_Stop():
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/USI_TWI_Master.c:162
#else
  DELAY_T2TWI; // Delay for T2TWI if TWI_STANDARD_MODE
#endif

  /* Generate Start Condition */
  PORT_USI &= ~(1 << PIN_USI_SDA); // Force SDA LOW.
     5d4:	69 98       	cbi	0x0d, 1	; 13
_delay_us():
c:\users\táta\appdata\local\arduino15\packages\arduino\tools\avr-gcc\7.3.0-atmel3.6.1-arduino5\avr\include\util/delay.h:276
     5d6:	26 e0       	ldi	r18, 0x06	; 6
     5d8:	2a 95       	dec	r18
     5da:	f1 f7       	brne	.-4      	; 0x5d8 <USI_TWI_Start_Transceiver_With_Data_Stop+0x34>
     5dc:	00 c0       	rjmp	.+0      	; 0x5de <USI_TWI_Start_Transceiver_With_Data_Stop+0x3a>
USI_TWI_Start_Transceiver_With_Data_Stop():
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/USI_TWI_Master.c:164
  DELAY_T4TWI;
  PORT_USI_CL &= ~(1 << PIN_USI_SCL); // Pull SCL LOW.
     5de:	49 98       	cbi	0x09, 1	; 9
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/USI_TWI_Master.c:165
  PORT_USI |= (1 << PIN_USI_SDA);  // Release SDA.
     5e0:	69 9a       	sbi	0x0d, 1	; 13
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/USI_TWI_Master.c:168

#ifdef SIGNAL_VERIFY
  if (!(USISR & (1 << USISIF))) {
     5e2:	0b b4       	in	r0, 0x2b	; 43
     5e4:	07 fc       	sbrc	r0, 7
     5e6:	0b c0       	rjmp	.+22     	; 0x5fe <USI_TWI_Start_Transceiver_With_Data_Stop+0x5a>
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/USI_TWI_Master.c:169
    USI_TWI_state.errorState = USI_TWI_MISSING_START_CON;
     5e8:	87 e0       	ldi	r24, 0x07	; 7
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/USI_TWI_Master.c:187

      /* Clock and verify (N)ACK from slave */
      DDR_USI &= ~(1 << PIN_USI_SDA); // Enable SDA as input.
      if (USI_TWI_Master_Transfer(tempUSISR_1bit) & (1 << TWI_NACK_BIT)) {
        if (USI_TWI_state.addressMode)
          USI_TWI_state.errorState = USI_TWI_NO_ACK_ON_ADDRESS;
     5ea:	80 93 5f 01 	sts	0x015F, r24	; 0x80015f <USI_TWI_state>
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/USI_TWI_Master.c:190
        else
          USI_TWI_state.errorState = USI_TWI_NO_ACK_ON_DATA;
        return (FALSE);
     5ee:	10 e0       	ldi	r17, 0x00	; 0
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/USI_TWI_Master.c:217
    USI_TWI_Master_Stop(); // Send a STOP condition on the TWI bus.
  }

  /* Transmission successfully completed*/
  return (TRUE);
}
     5f0:	81 2f       	mov	r24, r17
     5f2:	df 91       	pop	r29
     5f4:	cf 91       	pop	r28
     5f6:	1f 91       	pop	r17
     5f8:	0f 91       	pop	r16
     5fa:	ff 90       	pop	r15
     5fc:	08 95       	ret
     5fe:	ec 01       	movw	r28, r24
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/USI_TWI_Master.c:203
      *(msg++) = USI_TWI_Master_Transfer(tempUSISR_8bit);

      /* Prepare to generate ACK (or NACK in case of End Of Transmission) */
      if (msgSize == 1) // If transmission of last byte was performed.
      {
        USIDR = 0xFF; // Load NACK to confirm End Of Transmission.
     600:	ff 24       	eor	r15, r15
     602:	fa 94       	dec	r15
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/USI_TWI_Master.c:177
#endif

  /*Write address and Read/Write data */
  do {
    /* If masterWrite cycle (or initial address transmission)*/
    if (USI_TWI_state.addressMode || USI_TWI_state.masterWriteDataMode) {
     604:	80 91 5f 01 	lds	r24, 0x015F	; 0x80015f <USI_TWI_state>
     608:	83 70       	andi	r24, 0x03	; 3
     60a:	29 f1       	breq	.+74     	; 0x656 <USI_TWI_Start_Transceiver_With_Data_Stop+0xb2>
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/USI_TWI_Master.c:179
      /* Write a byte */
      PORT_USI_CL &= ~(1 << PIN_USI_SCL);         // Pull SCL LOW.
     60c:	49 98       	cbi	0x09, 1	; 9
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/USI_TWI_Master.c:180
      USIDR = *(msg++);                        // Setup data.
     60e:	88 81       	ld	r24, Y
     610:	8c bd       	out	0x2c, r24	; 44
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/USI_TWI_Master.c:181
      USI_TWI_Master_Transfer(tempUSISR_8bit); // Send 8 bits on bus.
     612:	80 ef       	ldi	r24, 0xF0	; 240
     614:	0e 94 ba 02 	call	0x574	; 0x574 <USI_TWI_Master_Transfer>
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/USI_TWI_Master.c:184

      /* Clock and verify (N)ACK from slave */
      DDR_USI &= ~(1 << PIN_USI_SDA); // Enable SDA as input.
     618:	61 98       	cbi	0x0c, 1	; 12
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/USI_TWI_Master.c:185
      if (USI_TWI_Master_Transfer(tempUSISR_1bit) & (1 << TWI_NACK_BIT)) {
     61a:	8e ef       	ldi	r24, 0xFE	; 254
     61c:	0e 94 ba 02 	call	0x574	; 0x574 <USI_TWI_Master_Transfer>
     620:	80 ff       	sbrs	r24, 0
     622:	0c c0       	rjmp	.+24     	; 0x63c <USI_TWI_Start_Transceiver_With_Data_Stop+0x98>
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/USI_TWI_Master.c:186
        if (USI_TWI_state.addressMode)
     624:	80 91 5f 01 	lds	r24, 0x015F	; 0x80015f <USI_TWI_state>
     628:	18 2f       	mov	r17, r24
     62a:	11 70       	andi	r17, 0x01	; 1
     62c:	80 ff       	sbrs	r24, 0
     62e:	02 c0       	rjmp	.+4      	; 0x634 <USI_TWI_Start_Transceiver_With_Data_Stop+0x90>
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/USI_TWI_Master.c:187
          USI_TWI_state.errorState = USI_TWI_NO_ACK_ON_ADDRESS;
     630:	86 e0       	ldi	r24, 0x06	; 6
     632:	db cf       	rjmp	.-74     	; 0x5ea <USI_TWI_Start_Transceiver_With_Data_Stop+0x46>
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/USI_TWI_Master.c:189
        else
          USI_TWI_state.errorState = USI_TWI_NO_ACK_ON_DATA;
     634:	85 e0       	ldi	r24, 0x05	; 5
USI_TWI_Master_Stop():
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/USI_TWI_Master.c:265
  PORT_USI |= (1 << PIN_USI_SDA); // Release SDA.
  DELAY_T2TWI;

#ifdef SIGNAL_VERIFY
  if (!(USISR & (1 << USIPF))) {
    USI_TWI_state.errorState = USI_TWI_MISSING_STOP_CON;
     636:	80 93 5f 01 	sts	0x015F, r24	; 0x80015f <USI_TWI_state>
     63a:	da cf       	rjmp	.-76     	; 0x5f0 <USI_TWI_Start_Transceiver_With_Data_Stop+0x4c>
USI_TWI_Start_Transceiver_With_Data_Stop():
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/USI_TWI_Master.c:192
          USI_TWI_state.errorState = USI_TWI_NO_ACK_ON_ADDRESS;
        else
          USI_TWI_state.errorState = USI_TWI_NO_ACK_ON_DATA;
        return (FALSE);
      }
      USI_TWI_state.addressMode = FALSE; // Only perform address transmission once.
     63c:	80 91 5f 01 	lds	r24, 0x015F	; 0x80015f <USI_TWI_state>
     640:	8e 7f       	andi	r24, 0xFE	; 254
     642:	80 93 5f 01 	sts	0x015F, r24	; 0x80015f <USI_TWI_state>
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/USI_TWI_Master.c:209
      } else {
        USIDR = 0x00; // Load ACK. Set data register bit 7 (output for SDA) low.
      }
      USI_TWI_Master_Transfer(tempUSISR_1bit); // Generate ACK/NACK.
    }
  } while (--msgSize); // Until all data sent/received.
     646:	01 50       	subi	r16, 0x01	; 1
     648:	21 96       	adiw	r28, 0x01	; 1
     64a:	01 11       	cpse	r16, r1
     64c:	db cf       	rjmp	.-74     	; 0x604 <USI_TWI_Start_Transceiver_With_Data_Stop+0x60>
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/USI_TWI_Master.c:211

  if (stop) {
     64e:	11 11       	cpse	r17, r1
     650:	10 c0       	rjmp	.+32     	; 0x672 <USI_TWI_Start_Transceiver_With_Data_Stop+0xce>
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/USI_TWI_Master.c:216
    USI_TWI_Master_Stop(); // Send a STOP condition on the TWI bus.
  }

  /* Transmission successfully completed*/
  return (TRUE);
     652:	11 e0       	ldi	r17, 0x01	; 1
     654:	cd cf       	rjmp	.-102    	; 0x5f0 <USI_TWI_Start_Transceiver_With_Data_Stop+0x4c>
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/USI_TWI_Master.c:197
      USI_TWI_state.addressMode = FALSE; // Only perform address transmission once.
    }
    /* Else masterRead cycle*/
    else {
      /* Read a data byte */
      DDR_USI &= ~(1 << PIN_USI_SDA); // Enable SDA as input.
     656:	61 98       	cbi	0x0c, 1	; 12
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/USI_TWI_Master.c:198
      *(msg++) = USI_TWI_Master_Transfer(tempUSISR_8bit);
     658:	80 ef       	ldi	r24, 0xF0	; 240
     65a:	0e 94 ba 02 	call	0x574	; 0x574 <USI_TWI_Master_Transfer>
     65e:	88 83       	st	Y, r24
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/USI_TWI_Master.c:201

      /* Prepare to generate ACK (or NACK in case of End Of Transmission) */
      if (msgSize == 1) // If transmission of last byte was performed.
     660:	01 30       	cpi	r16, 0x01	; 1
     662:	29 f4       	brne	.+10     	; 0x66e <USI_TWI_Start_Transceiver_With_Data_Stop+0xca>
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/USI_TWI_Master.c:203
      {
        USIDR = 0xFF; // Load NACK to confirm End Of Transmission.
     664:	fc bc       	out	0x2c, r15	; 44
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/USI_TWI_Master.c:207
      } else {
        USIDR = 0x00; // Load ACK. Set data register bit 7 (output for SDA) low.
      }
      USI_TWI_Master_Transfer(tempUSISR_1bit); // Generate ACK/NACK.
     666:	8e ef       	ldi	r24, 0xFE	; 254
     668:	0e 94 ba 02 	call	0x574	; 0x574 <USI_TWI_Master_Transfer>
     66c:	ec cf       	rjmp	.-40     	; 0x646 <USI_TWI_Start_Transceiver_With_Data_Stop+0xa2>
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/USI_TWI_Master.c:205
      /* Prepare to generate ACK (or NACK in case of End Of Transmission) */
      if (msgSize == 1) // If transmission of last byte was performed.
      {
        USIDR = 0xFF; // Load NACK to confirm End Of Transmission.
      } else {
        USIDR = 0x00; // Load ACK. Set data register bit 7 (output for SDA) low.
     66e:	1c bc       	out	0x2c, r1	; 44
     670:	fa cf       	rjmp	.-12     	; 0x666 <USI_TWI_Start_Transceiver_With_Data_Stop+0xc2>
USI_TWI_Master_Stop():
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/USI_TWI_Master.c:255
 Function for generating a TWI Stop Condition. Used to release
 the TWI bus.
---------------------------------------------------------------*/
unsigned char USI_TWI_Master_Stop(void)
{
  PORT_USI &= ~(1 << PIN_USI_SDA); // Pull SDA low.
     672:	69 98       	cbi	0x0d, 1	; 13
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/USI_TWI_Master.c:256
  PORT_USI_CL |= (1 << PIN_USI_SCL);  // Release SCL.
     674:	49 9a       	sbi	0x09, 1	; 9
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/USI_TWI_Master.c:257
  while (!(PIN_USI_CL & (1 << PIN_USI_SCL)))
     676:	39 9b       	sbis	0x07, 1	; 7
     678:	fe cf       	rjmp	.-4      	; 0x676 <USI_TWI_Start_Transceiver_With_Data_Stop+0xd2>
_delay_us():
c:\users\táta\appdata\local\arduino15\packages\arduino\tools\avr-gcc\7.3.0-atmel3.6.1-arduino5\avr\include\util/delay.h:276
     67a:	86 e0       	ldi	r24, 0x06	; 6
     67c:	8a 95       	dec	r24
     67e:	f1 f7       	brne	.-4      	; 0x67c <USI_TWI_Start_Transceiver_With_Data_Stop+0xd8>
     680:	00 c0       	rjmp	.+0      	; 0x682 <USI_TWI_Start_Transceiver_With_Data_Stop+0xde>
USI_TWI_Master_Stop():
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/USI_TWI_Master.c:260
    ; // Wait for SCL to go high.
  DELAY_T4TWI;
  PORT_USI |= (1 << PIN_USI_SDA); // Release SDA.
     682:	69 9a       	sbi	0x0d, 1	; 13
_delay_us():
c:\users\táta\appdata\local\arduino15\packages\arduino\tools\avr-gcc\7.3.0-atmel3.6.1-arduino5\avr\include\util/delay.h:276
     684:	ee e0       	ldi	r30, 0x0E	; 14
     686:	ea 95       	dec	r30
     688:	f1 f7       	brne	.-4      	; 0x686 <USI_TWI_Start_Transceiver_With_Data_Stop+0xe2>
USI_TWI_Master_Stop():
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/USI_TWI_Master.c:264
  DELAY_T2TWI;

#ifdef SIGNAL_VERIFY
  if (!(USISR & (1 << USIPF))) {
     68a:	0b b4       	in	r0, 0x2b	; 43
     68c:	05 fc       	sbrc	r0, 5
     68e:	e1 cf       	rjmp	.-62     	; 0x652 <USI_TWI_Start_Transceiver_With_Data_Stop+0xae>
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/USI_TWI_Master.c:265
    USI_TWI_state.errorState = USI_TWI_MISSING_STOP_CON;
     690:	88 e0       	ldi	r24, 0x08	; 8
     692:	d1 cf       	rjmp	.-94     	; 0x636 <USI_TWI_Start_Transceiver_With_Data_Stop+0x92>

00000694 <TwoWire::endTransmission() [clone .constprop.18]>:
_ZN7TwoWire15endTransmissionEv.constprop.18():
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/Wire.cpp:469

uint8_t TwoWire::endTransmission(uint8_t sendStop) {
  // transmit buffer (blocking)
  uint8_t ret = USI_TWI_Start_Transceiver_With_Data_Stop(Buffer,
                                                         BufferLength,
                                                         sendStop);
     694:	41 e0       	ldi	r20, 0x01	; 1
     696:	60 91 60 01 	lds	r22, 0x0160	; 0x800160 <TwoWire::BufferLength>
     69a:	84 e0       	ldi	r24, 0x04	; 4
     69c:	91 e0       	ldi	r25, 0x01	; 1
     69e:	0e 94 d2 02 	call	0x5a4	; 0x5a4 <USI_TWI_Start_Transceiver_With_Data_Stop>
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/Wire.cpp:471
  // reset tx buffer iterator vars
  BufferIndex = 0;
     6a2:	10 92 61 01 	sts	0x0161, r1	; 0x800161 <TwoWire::BufferIndex>
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/Wire.cpp:472
  BufferLength = 0;
     6a6:	10 92 60 01 	sts	0x0160, r1	; 0x800160 <TwoWire::BufferLength>
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/Wire.cpp:474
  // indicate that we are done transmitting
  transmitting = 0;
     6aa:	10 92 62 01 	sts	0x0162, r1	; 0x800162 <TwoWire::transmitting>
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/Wire.cpp:476
  // check for error
  if (ret == FALSE) {
     6ae:	81 11       	cpse	r24, r1
     6b0:	10 c0       	rjmp	.+32     	; 0x6d2 <TwoWire::endTransmission() [clone .constprop.18]+0x3e>
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/Wire.cpp:477
    switch (USI_TWI_Get_State_Info()) {
     6b2:	80 91 5f 01 	lds	r24, 0x015F	; 0x80015f <USI_TWI_state>
     6b6:	85 30       	cpi	r24, 0x05	; 5
     6b8:	41 f0       	breq	.+16     	; 0x6ca <TwoWire::endTransmission() [clone .constprop.18]+0x36>
     6ba:	86 30       	cpi	r24, 0x06	; 6
     6bc:	21 f0       	breq	.+8      	; 0x6c6 <TwoWire::endTransmission() [clone .constprop.18]+0x32>
     6be:	81 30       	cpi	r24, 0x01	; 1
     6c0:	31 f4       	brne	.+12     	; 0x6ce <TwoWire::endTransmission() [clone .constprop.18]+0x3a>
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/Wire.cpp:479
    case USI_TWI_DATA_OUT_OF_BOUND:
      return 1; //data too long to fit in transmit buffer
     6c2:	81 e0       	ldi	r24, 0x01	; 1
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/Wire.cpp:492
  return 0; //success
}

uint8_t TwoWire::endTransmission(void) {
  return endTransmission(true);
}
     6c4:	08 95       	ret
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/Wire.cpp:481
  if (ret == FALSE) {
    switch (USI_TWI_Get_State_Info()) {
    case USI_TWI_DATA_OUT_OF_BOUND:
      return 1; //data too long to fit in transmit buffer
    case USI_TWI_NO_ACK_ON_ADDRESS:
      return 2; //received NACK on transmit of address
     6c6:	82 e0       	ldi	r24, 0x02	; 2
     6c8:	08 95       	ret
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/Wire.cpp:483
    case USI_TWI_NO_ACK_ON_DATA:
      return 3; //received NACK on transmit of data
     6ca:	83 e0       	ldi	r24, 0x03	; 3
     6cc:	08 95       	ret
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/Wire.cpp:485
    }
    return 4; //other error
     6ce:	84 e0       	ldi	r24, 0x04	; 4
     6d0:	08 95       	ret
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/Wire.cpp:487
  }
  return 0; //success
     6d2:	80 e0       	ldi	r24, 0x00	; 0
     6d4:	08 95       	ret

000006d6 <DS3231_set_addr(unsigned char, unsigned char)>:
_Z15DS3231_set_addrhh():
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/ds3231.cpp:145
    t->unixtime = get_unixtime(*t);
#endif
}

void DS3231_set_addr(const uint8_t addr, const uint8_t val)
{
     6d6:	cf 93       	push	r28
     6d8:	df 93       	push	r29
     6da:	d8 2f       	mov	r29, r24
     6dc:	c6 2f       	mov	r28, r22
beginTransmission():
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/Wire.cpp:462
  BufferIndex = 1; // reserved by slave address
  BufferLength = BufferIndex;
}

void TwoWire::beginTransmission(int address) {
  beginTransmission((uint8_t)address);
     6de:	88 e6       	ldi	r24, 0x68	; 104
     6e0:	0e 94 7d 00 	call	0xfa	; 0xfa <TwoWire::beginTransmission(unsigned char) [clone .constprop.21]>
_Z15DS3231_set_addrhh():
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/ds3231.cpp:147
    Wire.beginTransmission(DS3231_I2C_ADDR);
    Wire.write(addr);
     6e4:	8d 2f       	mov	r24, r29
     6e6:	0e 94 88 00 	call	0x110	; 0x110 <TwoWire::write(unsigned char) [clone .constprop.17]>
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/ds3231.cpp:148
    Wire.write(val);
     6ea:	8c 2f       	mov	r24, r28
     6ec:	0e 94 88 00 	call	0x110	; 0x110 <TwoWire::write(unsigned char) [clone .constprop.17]>
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/ds3231.cpp:150
    Wire.endTransmission();
}
     6f0:	df 91       	pop	r29
     6f2:	cf 91       	pop	r28
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/ds3231.cpp:149
void DS3231_set_addr(const uint8_t addr, const uint8_t val)
{
    Wire.beginTransmission(DS3231_I2C_ADDR);
    Wire.write(addr);
    Wire.write(val);
    Wire.endTransmission();
     6f4:	0c 94 4a 03 	jmp	0x694	; 0x694 <TwoWire::endTransmission() [clone .constprop.18]>

000006f8 <__vector_12>:
__vector_12():
C:\Users\táta\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\cores\tinymodern/wiring.c:81
volatile unsigned long millis_timer_overflow_count = 0;
volatile unsigned long millis_timer_millis = 0;
static unsigned char millis_timer_fract = 0;

ISR(MILLISTIMER_OVF_vect)
{
     6f8:	1f 92       	push	r1
     6fa:	0f 92       	push	r0
     6fc:	0f b6       	in	r0, 0x3f	; 63
     6fe:	0f 92       	push	r0
     700:	11 24       	eor	r1, r1
     702:	2f 93       	push	r18
     704:	3f 93       	push	r19
     706:	8f 93       	push	r24
     708:	9f 93       	push	r25
     70a:	af 93       	push	r26
     70c:	bf 93       	push	r27
C:\Users\táta\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\cores\tinymodern/wiring.c:84
  // copy these to local variables so they can be stored in registers
  // (volatile variables must be read from memory on every access)
  unsigned long m = millis_timer_millis;
     70e:	80 91 57 01 	lds	r24, 0x0157	; 0x800157 <millis_timer_millis>
     712:	90 91 58 01 	lds	r25, 0x0158	; 0x800158 <millis_timer_millis+0x1>
     716:	a0 91 59 01 	lds	r26, 0x0159	; 0x800159 <millis_timer_millis+0x2>
     71a:	b0 91 5a 01 	lds	r27, 0x015A	; 0x80015a <millis_timer_millis+0x3>
C:\Users\táta\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\cores\tinymodern/wiring.c:85
  unsigned char f = millis_timer_fract;
     71e:	30 91 27 01 	lds	r19, 0x0127	; 0x800127 <millis_timer_fract>
C:\Users\táta\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\cores\tinymodern/wiring.c:97
    f -= FRACT_MAX;
    m += 1;
  }
...rmv */

  f += FRACT_INC;
     722:	26 e0       	ldi	r18, 0x06	; 6
     724:	23 0f       	add	r18, r19
C:\Users\táta\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\cores\tinymodern/wiring.c:99

  if (f >= FRACT_MAX)
     726:	2d 37       	cpi	r18, 0x7D	; 125
     728:	68 f1       	brcs	.+90     	; 0x784 <__vector_12+0x8c>
C:\Users\táta\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\cores\tinymodern/wiring.c:101
  {
    f -= FRACT_MAX;
     72a:	29 e8       	ldi	r18, 0x89	; 137
     72c:	23 0f       	add	r18, r19
C:\Users\táta\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\cores\tinymodern/wiring.c:102
    m = m + MILLIS_INC + 1;
     72e:	03 96       	adiw	r24, 0x03	; 3
     730:	a1 1d       	adc	r26, r1
     732:	b1 1d       	adc	r27, r1
C:\Users\táta\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\cores\tinymodern/wiring.c:109
  else
  {
    m += MILLIS_INC;
  }

  millis_timer_fract = f;
     734:	20 93 27 01 	sts	0x0127, r18	; 0x800127 <millis_timer_fract>
C:\Users\táta\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\cores\tinymodern/wiring.c:110
  millis_timer_millis = m;
     738:	80 93 57 01 	sts	0x0157, r24	; 0x800157 <millis_timer_millis>
     73c:	90 93 58 01 	sts	0x0158, r25	; 0x800158 <millis_timer_millis+0x1>
     740:	a0 93 59 01 	sts	0x0159, r26	; 0x800159 <millis_timer_millis+0x2>
     744:	b0 93 5a 01 	sts	0x015A, r27	; 0x80015a <millis_timer_millis+0x3>
C:\Users\táta\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\cores\tinymodern/wiring.c:111
  millis_timer_overflow_count++;
     748:	80 91 28 01 	lds	r24, 0x0128	; 0x800128 <millis_timer_overflow_count>
     74c:	90 91 29 01 	lds	r25, 0x0129	; 0x800129 <millis_timer_overflow_count+0x1>
     750:	a0 91 2a 01 	lds	r26, 0x012A	; 0x80012a <millis_timer_overflow_count+0x2>
     754:	b0 91 2b 01 	lds	r27, 0x012B	; 0x80012b <millis_timer_overflow_count+0x3>
     758:	01 96       	adiw	r24, 0x01	; 1
     75a:	a1 1d       	adc	r26, r1
     75c:	b1 1d       	adc	r27, r1
     75e:	80 93 28 01 	sts	0x0128, r24	; 0x800128 <millis_timer_overflow_count>
     762:	90 93 29 01 	sts	0x0129, r25	; 0x800129 <millis_timer_overflow_count+0x1>
     766:	a0 93 2a 01 	sts	0x012A, r26	; 0x80012a <millis_timer_overflow_count+0x2>
     76a:	b0 93 2b 01 	sts	0x012B, r27	; 0x80012b <millis_timer_overflow_count+0x3>
C:\Users\táta\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\cores\tinymodern/wiring.c:112
}
     76e:	bf 91       	pop	r27
     770:	af 91       	pop	r26
     772:	9f 91       	pop	r25
     774:	8f 91       	pop	r24
     776:	3f 91       	pop	r19
     778:	2f 91       	pop	r18
     77a:	0f 90       	pop	r0
     77c:	0f be       	out	0x3f, r0	; 63
     77e:	0f 90       	pop	r0
     780:	1f 90       	pop	r1
     782:	18 95       	reti
C:\Users\táta\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\cores\tinymodern/wiring.c:106
    f -= FRACT_MAX;
    m = m + MILLIS_INC + 1;
  }
  else
  {
    m += MILLIS_INC;
     784:	02 96       	adiw	r24, 0x02	; 2
     786:	a1 1d       	adc	r26, r1
     788:	b1 1d       	adc	r27, r1
     78a:	d4 cf       	rjmp	.-88     	; 0x734 <__vector_12+0x3c>

0000078c <__vector_7>:
__vector_7():
C:\Users\táta\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\libraries\Servo_ATTinyCore\src\avr/Servo_ATTinyCore.cpp:1062

#ifndef WIRING // Wiring pre-defines signal handlers so don't define any if compiling for the Wiring platform
// Interrupt handlers for Arduino
#if defined(_useTimer1)
SIGNAL (TIMER1_COMPA_vect)
{
     78c:	1f 92       	push	r1
     78e:	0f 92       	push	r0
     790:	0f b6       	in	r0, 0x3f	; 63
     792:	0f 92       	push	r0
     794:	11 24       	eor	r1, r1
     796:	2f 93       	push	r18
     798:	3f 93       	push	r19
     79a:	4f 93       	push	r20
     79c:	5f 93       	push	r21
     79e:	6f 93       	push	r22
     7a0:	7f 93       	push	r23
     7a2:	8f 93       	push	r24
     7a4:	9f 93       	push	r25
     7a6:	af 93       	push	r26
     7a8:	bf 93       	push	r27
     7aa:	cf 93       	push	r28
     7ac:	df 93       	push	r29
     7ae:	ef 93       	push	r30
     7b0:	ff 93       	push	r31
handle_interrupts():
C:\Users\táta\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\libraries\Servo_ATTinyCore\src\avr/Servo_ATTinyCore.cpp:1035

/************ static functions common to all instances ***********************/

static inline void handle_interrupts(timer16_Sequence_t timer, volatile uint16_t *TCNTn, volatile uint16_t* OCRnA)
{
  if( Channel[timer] < 0 )
     7b2:	80 91 26 01 	lds	r24, 0x0126	; 0x800126 <Channel>
     7b6:	c0 91 25 01 	lds	r28, 0x0125	; 0x800125 <ServoCount>
     7ba:	d0 e0       	ldi	r29, 0x00	; 0
     7bc:	87 ff       	sbrs	r24, 7
     7be:	24 c0       	rjmp	.+72     	; 0x808 <__vector_7+0x7c>
C:\Users\táta\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\libraries\Servo_ATTinyCore\src\avr/Servo_ATTinyCore.cpp:1036
    *TCNTn = 0; // channel set to -1 indicated that refresh interval completed so reset the timer
     7c0:	10 92 6f 00 	sts	0x006F, r1	; 0x80006f <__EEPROM_REGION_LENGTH__+0x7f006f>
     7c4:	10 92 6e 00 	sts	0x006E, r1	; 0x80006e <__EEPROM_REGION_LENGTH__+0x7f006e>
C:\Users\táta\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\libraries\Servo_ATTinyCore\src\avr/Servo_ATTinyCore.cpp:1042
  else{
    if( SERVO_INDEX(timer,Channel[timer]) < ServoCount && SERVO(timer,Channel[timer]).Pin.isActive == true )
      digitalWrite( SERVO(timer,Channel[timer]).Pin.nbr,LOW); // pulse this channel low if activated
  }

  Channel[timer]++;    // increment to the next channel
     7c8:	80 91 26 01 	lds	r24, 0x0126	; 0x800126 <Channel>
     7cc:	8f 5f       	subi	r24, 0xFF	; 255
     7ce:	80 93 26 01 	sts	0x0126, r24	; 0x800126 <Channel>
C:\Users\táta\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\libraries\Servo_ATTinyCore\src\avr/Servo_ATTinyCore.cpp:1043
  if( SERVO_INDEX(timer,Channel[timer]) < ServoCount && Channel[timer] < SERVOS_PER_TIMER) {
     7d2:	80 91 26 01 	lds	r24, 0x0126	; 0x800126 <Channel>
     7d6:	08 2e       	mov	r0, r24
     7d8:	00 0c       	add	r0, r0
     7da:	99 0b       	sbc	r25, r25
     7dc:	8c 17       	cp	r24, r28
     7de:	9d 07       	cpc	r25, r29
     7e0:	24 f4       	brge	.+8      	; 0x7ea <__vector_7+0x5e>
     7e2:	80 91 26 01 	lds	r24, 0x0126	; 0x800126 <Channel>
     7e6:	8c 30       	cpi	r24, 0x0C	; 12
     7e8:	c4 f1       	brlt	.+112    	; 0x85a <__vector_7+0xce>
C:\Users\táta\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\libraries\Servo_ATTinyCore\src\avr/Servo_ATTinyCore.cpp:1050
    if(SERVO(timer,Channel[timer]).Pin.isActive == true)     // check if activated
      digitalWrite( SERVO(timer,Channel[timer]).Pin.nbr,HIGH); // its an active channel so pulse it high
  }
  else {
    // finished all channels so wait for the refresh period to expire before starting over
    if( ((unsigned)*TCNTn) + 4 < usToTicks(REFRESH_INTERVAL) )  // allow a few ticks to ensure the next OCR1A not missed
     7ea:	80 91 6e 00 	lds	r24, 0x006E	; 0x80006e <__EEPROM_REGION_LENGTH__+0x7f006e>
     7ee:	90 91 6f 00 	lds	r25, 0x006F	; 0x80006f <__EEPROM_REGION_LENGTH__+0x7f006f>
     7f2:	04 96       	adiw	r24, 0x04	; 4
     7f4:	80 32       	cpi	r24, 0x20	; 32
     7f6:	9e 44       	sbci	r25, 0x4E	; 78
     7f8:	08 f4       	brcc	.+2      	; 0x7fc <__vector_7+0x70>
     7fa:	7a c0       	rjmp	.+244    	; 0x8f0 <__vector_7+0x164>
C:\Users\táta\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\libraries\Servo_ATTinyCore\src\avr/Servo_ATTinyCore.cpp:1053
      *OCRnA = (unsigned int)usToTicks(REFRESH_INTERVAL);
    else
      *OCRnA = *TCNTn + 4;  // at least REFRESH_INTERVAL has elapsed
     7fc:	80 91 6e 00 	lds	r24, 0x006E	; 0x80006e <__EEPROM_REGION_LENGTH__+0x7f006e>
     800:	90 91 6f 00 	lds	r25, 0x006F	; 0x80006f <__EEPROM_REGION_LENGTH__+0x7f006f>
     804:	04 96       	adiw	r24, 0x04	; 4
     806:	76 c0       	rjmp	.+236    	; 0x8f4 <__vector_7+0x168>
C:\Users\táta\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\libraries\Servo_ATTinyCore\src\avr/Servo_ATTinyCore.cpp:1038
static inline void handle_interrupts(timer16_Sequence_t timer, volatile uint16_t *TCNTn, volatile uint16_t* OCRnA)
{
  if( Channel[timer] < 0 )
    *TCNTn = 0; // channel set to -1 indicated that refresh interval completed so reset the timer
  else{
    if( SERVO_INDEX(timer,Channel[timer]) < ServoCount && SERVO(timer,Channel[timer]).Pin.isActive == true )
     808:	80 91 26 01 	lds	r24, 0x0126	; 0x800126 <Channel>
     80c:	08 2e       	mov	r0, r24
     80e:	00 0c       	add	r0, r0
     810:	99 0b       	sbc	r25, r25
     812:	8c 17       	cp	r24, r28
     814:	9d 07       	cpc	r25, r29
     816:	c4 f6       	brge	.-80     	; 0x7c8 <__vector_7+0x3c>
     818:	80 91 26 01 	lds	r24, 0x0126	; 0x800126 <Channel>
     81c:	08 2e       	mov	r0, r24
     81e:	00 0c       	add	r0, r0
     820:	99 0b       	sbc	r25, r25
     822:	63 e0       	ldi	r22, 0x03	; 3
     824:	70 e0       	ldi	r23, 0x00	; 0
     826:	0e 94 e1 07 	call	0xfc2	; 0xfc2 <__mulhi3>
     82a:	80 5d       	subi	r24, 0xD0	; 208
     82c:	9e 4f       	sbci	r25, 0xFE	; 254
     82e:	fc 01       	movw	r30, r24
     830:	80 81       	ld	r24, Z
     832:	86 ff       	sbrs	r24, 6
     834:	c9 cf       	rjmp	.-110    	; 0x7c8 <__vector_7+0x3c>
C:\Users\táta\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\libraries\Servo_ATTinyCore\src\avr/Servo_ATTinyCore.cpp:1039
      digitalWrite( SERVO(timer,Channel[timer]).Pin.nbr,LOW); // pulse this channel low if activated
     836:	80 91 26 01 	lds	r24, 0x0126	; 0x800126 <Channel>
     83a:	08 2e       	mov	r0, r24
     83c:	00 0c       	add	r0, r0
     83e:	99 0b       	sbc	r25, r25
     840:	63 e0       	ldi	r22, 0x03	; 3
     842:	70 e0       	ldi	r23, 0x00	; 0
     844:	0e 94 e1 07 	call	0xfc2	; 0xfc2 <__mulhi3>
     848:	80 5d       	subi	r24, 0xD0	; 208
     84a:	9e 4f       	sbci	r25, 0xFE	; 254
     84c:	fc 01       	movw	r30, r24
     84e:	80 81       	ld	r24, Z
     850:	60 e0       	ldi	r22, 0x00	; 0
     852:	8f 73       	andi	r24, 0x3F	; 63
     854:	0e 94 6a 01 	call	0x2d4	; 0x2d4 <digitalWrite>
     858:	b7 cf       	rjmp	.-146    	; 0x7c8 <__vector_7+0x3c>
C:\Users\táta\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\libraries\Servo_ATTinyCore\src\avr/Servo_ATTinyCore.cpp:1044
  }

  Channel[timer]++;    // increment to the next channel
  if( SERVO_INDEX(timer,Channel[timer]) < ServoCount && Channel[timer] < SERVOS_PER_TIMER) {
    *OCRnA = *TCNTn + SERVO(timer,Channel[timer]).ticks;
     85a:	20 91 6e 00 	lds	r18, 0x006E	; 0x80006e <__EEPROM_REGION_LENGTH__+0x7f006e>
     85e:	30 91 6f 00 	lds	r19, 0x006F	; 0x80006f <__EEPROM_REGION_LENGTH__+0x7f006f>
     862:	80 91 26 01 	lds	r24, 0x0126	; 0x800126 <Channel>
     866:	08 2e       	mov	r0, r24
     868:	00 0c       	add	r0, r0
     86a:	99 0b       	sbc	r25, r25
     86c:	63 e0       	ldi	r22, 0x03	; 3
     86e:	70 e0       	ldi	r23, 0x00	; 0
     870:	0e 94 e1 07 	call	0xfc2	; 0xfc2 <__mulhi3>
     874:	80 5d       	subi	r24, 0xD0	; 208
     876:	9e 4f       	sbci	r25, 0xFE	; 254
     878:	fc 01       	movw	r30, r24
     87a:	81 81       	ldd	r24, Z+1	; 0x01
     87c:	92 81       	ldd	r25, Z+2	; 0x02
     87e:	28 0f       	add	r18, r24
     880:	39 1f       	adc	r19, r25
     882:	30 93 6d 00 	sts	0x006D, r19	; 0x80006d <__EEPROM_REGION_LENGTH__+0x7f006d>
     886:	20 93 6c 00 	sts	0x006C, r18	; 0x80006c <__EEPROM_REGION_LENGTH__+0x7f006c>
C:\Users\táta\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\libraries\Servo_ATTinyCore\src\avr/Servo_ATTinyCore.cpp:1045
    if(SERVO(timer,Channel[timer]).Pin.isActive == true)     // check if activated
     88a:	80 91 26 01 	lds	r24, 0x0126	; 0x800126 <Channel>
     88e:	08 2e       	mov	r0, r24
     890:	00 0c       	add	r0, r0
     892:	99 0b       	sbc	r25, r25
     894:	63 e0       	ldi	r22, 0x03	; 3
     896:	70 e0       	ldi	r23, 0x00	; 0
     898:	0e 94 e1 07 	call	0xfc2	; 0xfc2 <__mulhi3>
     89c:	80 5d       	subi	r24, 0xD0	; 208
     89e:	9e 4f       	sbci	r25, 0xFE	; 254
     8a0:	fc 01       	movw	r30, r24
     8a2:	80 81       	ld	r24, Z
     8a4:	86 ff       	sbrs	r24, 6
     8a6:	11 c0       	rjmp	.+34     	; 0x8ca <__vector_7+0x13e>
C:\Users\táta\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\libraries\Servo_ATTinyCore\src\avr/Servo_ATTinyCore.cpp:1046
      digitalWrite( SERVO(timer,Channel[timer]).Pin.nbr,HIGH); // its an active channel so pulse it high
     8a8:	80 91 26 01 	lds	r24, 0x0126	; 0x800126 <Channel>
     8ac:	08 2e       	mov	r0, r24
     8ae:	00 0c       	add	r0, r0
     8b0:	99 0b       	sbc	r25, r25
     8b2:	63 e0       	ldi	r22, 0x03	; 3
     8b4:	70 e0       	ldi	r23, 0x00	; 0
     8b6:	0e 94 e1 07 	call	0xfc2	; 0xfc2 <__mulhi3>
     8ba:	80 5d       	subi	r24, 0xD0	; 208
     8bc:	9e 4f       	sbci	r25, 0xFE	; 254
     8be:	fc 01       	movw	r30, r24
     8c0:	80 81       	ld	r24, Z
     8c2:	61 e0       	ldi	r22, 0x01	; 1
     8c4:	8f 73       	andi	r24, 0x3F	; 63
     8c6:	0e 94 6a 01 	call	0x2d4	; 0x2d4 <digitalWrite>
__vector_7():
C:\Users\táta\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\libraries\Servo_ATTinyCore\src\avr/Servo_ATTinyCore.cpp:1064
// Interrupt handlers for Arduino
#if defined(_useTimer1)
SIGNAL (TIMER1_COMPA_vect)
{
  handle_interrupts(_timer1, &TCNT1, &OCR1A);
}
     8ca:	ff 91       	pop	r31
     8cc:	ef 91       	pop	r30
     8ce:	df 91       	pop	r29
     8d0:	cf 91       	pop	r28
     8d2:	bf 91       	pop	r27
     8d4:	af 91       	pop	r26
     8d6:	9f 91       	pop	r25
     8d8:	8f 91       	pop	r24
     8da:	7f 91       	pop	r23
     8dc:	6f 91       	pop	r22
     8de:	5f 91       	pop	r21
     8e0:	4f 91       	pop	r20
     8e2:	3f 91       	pop	r19
     8e4:	2f 91       	pop	r18
     8e6:	0f 90       	pop	r0
     8e8:	0f be       	out	0x3f, r0	; 63
     8ea:	0f 90       	pop	r0
     8ec:	1f 90       	pop	r1
     8ee:	18 95       	reti
handle_interrupts():
C:\Users\táta\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\libraries\Servo_ATTinyCore\src\avr/Servo_ATTinyCore.cpp:1051
      digitalWrite( SERVO(timer,Channel[timer]).Pin.nbr,HIGH); // its an active channel so pulse it high
  }
  else {
    // finished all channels so wait for the refresh period to expire before starting over
    if( ((unsigned)*TCNTn) + 4 < usToTicks(REFRESH_INTERVAL) )  // allow a few ticks to ensure the next OCR1A not missed
      *OCRnA = (unsigned int)usToTicks(REFRESH_INTERVAL);
     8f0:	80 e2       	ldi	r24, 0x20	; 32
     8f2:	9e e4       	ldi	r25, 0x4E	; 78
C:\Users\táta\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\libraries\Servo_ATTinyCore\src\avr/Servo_ATTinyCore.cpp:1053
    else
      *OCRnA = *TCNTn + 4;  // at least REFRESH_INTERVAL has elapsed
     8f4:	90 93 6d 00 	sts	0x006D, r25	; 0x80006d <__EEPROM_REGION_LENGTH__+0x7f006d>
     8f8:	80 93 6c 00 	sts	0x006C, r24	; 0x80006c <__EEPROM_REGION_LENGTH__+0x7f006c>
C:\Users\táta\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\libraries\Servo_ATTinyCore\src\avr/Servo_ATTinyCore.cpp:1054
    Channel[timer] = -1; // this will get incremented at the end of the refresh period to start again at the first channel
     8fc:	8f ef       	ldi	r24, 0xFF	; 255
     8fe:	80 93 26 01 	sts	0x0126, r24	; 0x800126 <Channel>
     902:	e3 cf       	rjmp	.-58     	; 0x8ca <__vector_7+0x13e>

00000904 <__vector_24>:
__vector_24():
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/USI_TWI_Slave.c:212
ISR(USI_OVERFLOW_VECTOR)
#elif __ICCAVR__
#pragma vector = USI_OVERFLOW_VECTOR
__interrupt void USI_Counter_Overflow_ISR(void)
#endif
{
     904:	1f 92       	push	r1
     906:	0f 92       	push	r0
     908:	0f b6       	in	r0, 0x3f	; 63
     90a:	0f 92       	push	r0
     90c:	11 24       	eor	r1, r1
     90e:	2f 93       	push	r18
     910:	8f 93       	push	r24
     912:	9f 93       	push	r25
     914:	ef 93       	push	r30
     916:	ff 93       	push	r31
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/USI_TWI_Slave.c:217
  unsigned char tmpRxHead;
  unsigned char tmpTxTail; // Temporary variables to store volatiles
  unsigned char tmpUSIDR;

  switch (USI_TWI_Overflow_State) {
     918:	80 91 24 01 	lds	r24, 0x0124	; 0x800124 <USI_TWI_Overflow_State>
     91c:	82 30       	cpi	r24, 0x02	; 2
     91e:	09 f4       	brne	.+2      	; 0x922 <__vector_24+0x1e>
     920:	5f c0       	rjmp	.+190    	; 0x9e0 <__vector_24+0xdc>
     922:	78 f4       	brcc	.+30     	; 0x942 <__vector_24+0x3e>
     924:	88 23       	and	r24, r24
     926:	49 f1       	breq	.+82     	; 0x97a <__vector_24+0x76>
     928:	81 30       	cpi	r24, 0x01	; 1
     92a:	09 f4       	brne	.+2      	; 0x92e <__vector_24+0x2a>
     92c:	3f c0       	rjmp	.+126    	; 0x9ac <__vector_24+0xa8>
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/USI_TWI_Slave.c:310
    {
      SET_USI_TO_SEND_NACK();
    }
    break;
  }
}
     92e:	ff 91       	pop	r31
     930:	ef 91       	pop	r30
     932:	9f 91       	pop	r25
     934:	8f 91       	pop	r24
     936:	2f 91       	pop	r18
     938:	0f 90       	pop	r0
     93a:	0f be       	out	0x3f, r0	; 63
     93c:	0f 90       	pop	r0
     93e:	1f 90       	pop	r1
     940:	18 95       	reti
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/USI_TWI_Slave.c:217
{
  unsigned char tmpRxHead;
  unsigned char tmpTxTail; // Temporary variables to store volatiles
  unsigned char tmpUSIDR;

  switch (USI_TWI_Overflow_State) {
     942:	84 30       	cpi	r24, 0x04	; 4
     944:	09 f4       	brne	.+2      	; 0x948 <__vector_24+0x44>
     946:	52 c0       	rjmp	.+164    	; 0x9ec <__vector_24+0xe8>
     948:	50 f1       	brcs	.+84     	; 0x99e <__vector_24+0x9a>
     94a:	85 30       	cpi	r24, 0x05	; 5
     94c:	81 f7       	brne	.-32     	; 0x92e <__vector_24+0x2a>
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/USI_TWI_Slave.c:297
    break;

  // Copy data from USIDR and send ACK. Next USI_SLAVE_REQUEST_DATA
  case USI_SLAVE_GET_DATA_AND_SEND_ACK:
    // Put data into Buffer
    USI_TWI_Overflow_State = USI_SLAVE_REQUEST_DATA;
     94e:	84 e0       	ldi	r24, 0x04	; 4
     950:	80 93 24 01 	sts	0x0124, r24	; 0x800124 <USI_TWI_Overflow_State>
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/USI_TWI_Slave.c:298
    tmpUSIDR              = USIDR; // Not necessary, but prevents warnings
     954:	9c b5       	in	r25, 0x2c	; 44
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/USI_TWI_Slave.c:299
    tmpRxHead = (TWI_RxHead + 1) & TWI_RX_BUFFER_MASK;
     956:	80 91 5b 01 	lds	r24, 0x015B	; 0x80015b <TWI_RxHead>
     95a:	8f 5f       	subi	r24, 0xFF	; 255
     95c:	8f 70       	andi	r24, 0x0F	; 15
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/USI_TWI_Slave.c:300
    if (TWI_RxTail != tmpRxHead) {
     95e:	20 91 5c 01 	lds	r18, 0x015C	; 0x80015c <TWI_RxTail>
     962:	28 17       	cp	r18, r24
     964:	09 f4       	brne	.+2      	; 0x968 <__vector_24+0x64>
     966:	47 c0       	rjmp	.+142    	; 0x9f6 <__vector_24+0xf2>
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/USI_TWI_Slave.c:301
      TWI_RxHead            = tmpRxHead;
     968:	80 93 5b 01 	sts	0x015B, r24	; 0x80015b <TWI_RxHead>
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/USI_TWI_Slave.c:302
      TWI_RxBuf[TWI_RxHead] = tmpUSIDR;
     96c:	e0 91 5b 01 	lds	r30, 0x015B	; 0x80015b <TWI_RxHead>
     970:	f0 e0       	ldi	r31, 0x00	; 0
     972:	ec 5f       	subi	r30, 0xFC	; 252
     974:	fe 4f       	sbci	r31, 0xFE	; 254
     976:	90 83       	st	Z, r25
     978:	0c c0       	rjmp	.+24     	; 0x992 <__vector_24+0x8e>
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/USI_TWI_Slave.c:221

  switch (USI_TWI_Overflow_State) {
  // ---------- Address mode ----------
  // Check address and send ACK (and next USI_SLAVE_SEND_DATA) if OK, else reset USI.
  case USI_SLAVE_CHECK_ADDRESS:
    if ((USIDR == 0) || ((USIDR >> 1) == TWI_slaveAddress)) {
     97a:	8c b5       	in	r24, 0x2c	; 44
     97c:	88 23       	and	r24, r24
     97e:	19 f0       	breq	.+6      	; 0x986 <__vector_24+0x82>
     980:	8c b5       	in	r24, 0x2c	; 44
     982:	86 95       	lsr	r24
     984:	79 f4       	brne	.+30     	; 0x9a4 <__vector_24+0xa0>
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/USI_TWI_Slave.c:222
      if (USIDR & 0x01) {
     986:	0c b4       	in	r0, 0x2c	; 44
     988:	00 fe       	sbrs	r0, 0
     98a:	07 c0       	rjmp	.+14     	; 0x99a <__vector_24+0x96>
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/USI_TWI_Slave.c:229
          // reset tx buffer and call callback
          tmpTxTail = TWI_TxHead;
          TWI_TxTail = tmpTxTail;
          USI_TWI_On_Slave_Transmit();
        }
        USI_TWI_Overflow_State = USI_SLAVE_SEND_DATA;
     98c:	81 e0       	ldi	r24, 0x01	; 1
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/USI_TWI_Slave.c:231
      } else {
        USI_TWI_Overflow_State = USI_SLAVE_REQUEST_DATA;
     98e:	80 93 24 01 	sts	0x0124, r24	; 0x800124 <USI_TWI_Overflow_State>
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/USI_TWI_Slave.c:233
      }
      SET_USI_TO_SEND_ACK();
     992:	1c bc       	out	0x2c, r1	; 44
     994:	61 9a       	sbi	0x0c, 1	; 12
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/USI_TWI_Slave.c:306
      TWI_RxHead            = tmpRxHead;
      TWI_RxBuf[TWI_RxHead] = tmpUSIDR;
      SET_USI_TO_SEND_ACK();
    } else // If the buffer is full then:
    {
      SET_USI_TO_SEND_NACK();
     996:	8e e7       	ldi	r24, 0x7E	; 126
     998:	21 c0       	rjmp	.+66     	; 0x9dc <__vector_24+0xd8>
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/USI_TWI_Slave.c:231
          TWI_TxTail = tmpTxTail;
          USI_TWI_On_Slave_Transmit();
        }
        USI_TWI_Overflow_State = USI_SLAVE_SEND_DATA;
      } else {
        USI_TWI_Overflow_State = USI_SLAVE_REQUEST_DATA;
     99a:	84 e0       	ldi	r24, 0x04	; 4
     99c:	f8 cf       	rjmp	.-16     	; 0x98e <__vector_24+0x8a>
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/USI_TWI_Slave.c:242
    break;

  // ----- Master write data mode ------
  // Check reply and goto USI_SLAVE_SEND_DATA if OK, else reset USI.
  case USI_SLAVE_CHECK_REPLY_FROM_SEND_DATA:
    if (USIDR) // If NACK, the master does not want more data.
     99e:	8c b5       	in	r24, 0x2c	; 44
     9a0:	88 23       	and	r24, r24
     9a2:	21 f0       	breq	.+8      	; 0x9ac <__vector_24+0xa8>
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/USI_TWI_Slave.c:259
    if (TWI_TxHead != tmpTxTail) {
      TWI_TxTail = (TWI_TxTail + 1) & TWI_TX_BUFFER_MASK;
      USIDR      = TWI_TxBuf[TWI_TxTail];
    } else // If the buffer is empty then:
    {
      SET_USI_TO_TWI_START_CONDITION_MODE();
     9a4:	61 98       	cbi	0x0c, 1	; 12
     9a6:	88 ea       	ldi	r24, 0xA8	; 168
     9a8:	8a bd       	out	0x2a, r24	; 42
     9aa:	17 c0       	rjmp	.+46     	; 0x9da <__vector_24+0xd6>
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/USI_TWI_Slave.c:253

  // Copy data from buffer to USIDR and set USI to shift byte. Next USI_SLAVE_REQUEST_REPLY_FROM_SEND_DATA
  case USI_SLAVE_SEND_DATA:

    // Get data from Buffer
    tmpTxTail = TWI_TxTail; // Not necessary, but prevents warnings
     9ac:	80 91 5d 01 	lds	r24, 0x015D	; 0x80015d <TWI_TxTail>
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/USI_TWI_Slave.c:254
    if (TWI_TxHead != tmpTxTail) {
     9b0:	90 91 5e 01 	lds	r25, 0x015E	; 0x80015e <TWI_TxHead>
     9b4:	98 17       	cp	r25, r24
     9b6:	b1 f3       	breq	.-20     	; 0x9a4 <__vector_24+0xa0>
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/USI_TWI_Slave.c:255
      TWI_TxTail = (TWI_TxTail + 1) & TWI_TX_BUFFER_MASK;
     9b8:	80 91 5d 01 	lds	r24, 0x015D	; 0x80015d <TWI_TxTail>
     9bc:	8f 5f       	subi	r24, 0xFF	; 255
     9be:	8f 70       	andi	r24, 0x0F	; 15
     9c0:	80 93 5d 01 	sts	0x015D, r24	; 0x80015d <TWI_TxTail>
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/USI_TWI_Slave.c:256
      USIDR      = TWI_TxBuf[TWI_TxTail];
     9c4:	e0 91 5d 01 	lds	r30, 0x015D	; 0x80015d <TWI_TxTail>
     9c8:	f0 e0       	ldi	r31, 0x00	; 0
     9ca:	ec 5e       	subi	r30, 0xEC	; 236
     9cc:	fe 4f       	sbci	r31, 0xFE	; 254
     9ce:	80 81       	ld	r24, Z
     9d0:	8c bd       	out	0x2c, r24	; 44
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/USI_TWI_Slave.c:262
    } else // If the buffer is empty then:
    {
      SET_USI_TO_TWI_START_CONDITION_MODE();
      return;
    }
    USI_TWI_Overflow_State = USI_SLAVE_REQUEST_REPLY_FROM_SEND_DATA;
     9d2:	82 e0       	ldi	r24, 0x02	; 2
     9d4:	80 93 24 01 	sts	0x0124, r24	; 0x800124 <USI_TWI_Overflow_State>
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/USI_TWI_Slave.c:263
    SET_USI_TO_SEND_DATA();
     9d8:	61 9a       	sbi	0x0c, 1	; 12
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/USI_TWI_Slave.c:276

  // ----- Master read data mode ------
  // Set USI to sample data from master. Next USI_SLAVE_GET_DATA_AND_SEND_ACK.
  case USI_SLAVE_REQUEST_DATA:
    USI_TWI_Overflow_State = USI_SLAVE_GET_DATA_AND_SEND_ACK;
    SET_USI_TO_READ_DATA();
     9da:	80 e7       	ldi	r24, 0x70	; 112
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/USI_TWI_Slave.c:306
      TWI_RxHead            = tmpRxHead;
      TWI_RxBuf[TWI_RxHead] = tmpUSIDR;
      SET_USI_TO_SEND_ACK();
    } else // If the buffer is full then:
    {
      SET_USI_TO_SEND_NACK();
     9dc:	8b bd       	out	0x2b, r24	; 43
     9de:	a7 cf       	rjmp	.-178    	; 0x92e <__vector_24+0x2a>
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/USI_TWI_Slave.c:268
    SET_USI_TO_SEND_DATA();
    break;

  // Set USI to sample reply from master. Next USI_SLAVE_CHECK_REPLY_FROM_SEND_DATA
  case USI_SLAVE_REQUEST_REPLY_FROM_SEND_DATA:
    USI_TWI_Overflow_State = USI_SLAVE_CHECK_REPLY_FROM_SEND_DATA;
     9e0:	83 e0       	ldi	r24, 0x03	; 3
     9e2:	80 93 24 01 	sts	0x0124, r24	; 0x800124 <USI_TWI_Overflow_State>
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/USI_TWI_Slave.c:269
    SET_USI_TO_READ_ACK();
     9e6:	61 98       	cbi	0x0c, 1	; 12
     9e8:	1c bc       	out	0x2c, r1	; 44
     9ea:	d5 cf       	rjmp	.-86     	; 0x996 <__vector_24+0x92>
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/USI_TWI_Slave.c:275
    break;

  // ----- Master read data mode ------
  // Set USI to sample data from master. Next USI_SLAVE_GET_DATA_AND_SEND_ACK.
  case USI_SLAVE_REQUEST_DATA:
    USI_TWI_Overflow_State = USI_SLAVE_GET_DATA_AND_SEND_ACK;
     9ec:	85 e0       	ldi	r24, 0x05	; 5
     9ee:	80 93 24 01 	sts	0x0124, r24	; 0x800124 <USI_TWI_Overflow_State>
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/USI_TWI_Slave.c:276
    SET_USI_TO_READ_DATA();
     9f2:	61 98       	cbi	0x0c, 1	; 12
     9f4:	f2 cf       	rjmp	.-28     	; 0x9da <__vector_24+0xd6>
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/USI_TWI_Slave.c:306
      TWI_RxHead            = tmpRxHead;
      TWI_RxBuf[TWI_RxHead] = tmpUSIDR;
      SET_USI_TO_SEND_ACK();
    } else // If the buffer is full then:
    {
      SET_USI_TO_SEND_NACK();
     9f6:	61 98       	cbi	0x0c, 1	; 12
     9f8:	ce cf       	rjmp	.-100    	; 0x996 <__vector_24+0x92>

000009fa <__vector_23>:
__vector_23():
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/USI_TWI_Slave.c:165
ISR(USI_START_VECTOR)
#elif __ICCAVR__
#pragma vector = USI_START_VECTOR
__interrupt void USI_Start_Condition_ISR(void)
#endif
{
     9fa:	1f 92       	push	r1
     9fc:	0f 92       	push	r0
     9fe:	0f b6       	in	r0, 0x3f	; 63
     a00:	0f 92       	push	r0
     a02:	11 24       	eor	r1, r1
     a04:	8f 93       	push	r24
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/USI_TWI_Slave.c:178
      // reset rx buffer
      TWI_RxTail = tmpRxHead;
    }
  }

  USI_TWI_Overflow_State = USI_SLAVE_CHECK_ADDRESS;
     a06:	10 92 24 01 	sts	0x0124, r1	; 0x800124 <USI_TWI_Overflow_State>
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/USI_TWI_Slave.c:179
  DDR_USI &= ~(1 << PORT_USI_SDA); // Set SDA as input
     a0a:	61 98       	cbi	0x0c, 1	; 12
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/USI_TWI_Slave.c:180
  while ((tmpPin = (PIN_USI_CL & (1 << PORT_USI_SCL))) && ((PIN_USI & (1 << PIN_USI_SDA)) == 0))
     a0c:	39 9b       	sbis	0x07, 1	; 7
     a0e:	04 c0       	rjmp	.+8      	; 0xa18 <__vector_23+0x1e>
     a10:	59 9b       	sbis	0x0b, 1	; 11
     a12:	fc cf       	rjmp	.-8      	; 0xa0c <__vector_23+0x12>
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/USI_TWI_Slave.c:185
    ; // Wait for SCL to go low to ensure the "Start Condition" has completed.
        // If a Stop condition arises then leave the interrupt to prevent waiting forever.
  if (tmpPin) {
    // Stop Condition (waiting for next Start Condition)
    USICR = (1 << USISIE) | (0 << USIOIE) | // Enable Start Condition Interrupt. Disable Overflow Interrupt.
     a14:	88 ea       	ldi	r24, 0xA8	; 168
     a16:	01 c0       	rjmp	.+2      	; 0xa1a <__vector_23+0x20>
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/USI_TWI_Slave.c:192
                                            // to first Start Condition (potential failure)
            (1 << USICS1) | (0 << USICS0) | (0 << USICLK) | // Shift Register Clock Source = External, positive edge
            (0 << USITC);
  } else {
    // really Start Condition (Enable Overflow Interrupt)
    USICR = (1 << USISIE) | (1 << USIOIE)
     a18:	88 ef       	ldi	r24, 0xF8	; 248
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/USI_TWI_Slave.c:185
  while ((tmpPin = (PIN_USI_CL & (1 << PORT_USI_SCL))) && ((PIN_USI & (1 << PIN_USI_SDA)) == 0))
    ; // Wait for SCL to go low to ensure the "Start Condition" has completed.
        // If a Stop condition arises then leave the interrupt to prevent waiting forever.
  if (tmpPin) {
    // Stop Condition (waiting for next Start Condition)
    USICR = (1 << USISIE) | (0 << USIOIE) | // Enable Start Condition Interrupt. Disable Overflow Interrupt.
     a1a:	8a bd       	out	0x2a, r24	; 42
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/USI_TWI_Slave.c:198
            | // Enable Overflow and Start Condition Interrupt. (Keep StartCondInt to detect RESTART)
            (1 << USIWM1) | (1 << USIWM0) |                 // Set USI in Two-wire mode.
            (1 << USICS1) | (0 << USICS0) | (0 << USICLK) | // Shift Register Clock Source = External, positive edge
            (0 << USITC);
  }
  USISR = (1 << USI_START_COND_INT) | (1 << USIOIF) | (1 << USIPF) | (1 << USIDC) | // Clear flags
     a1c:	80 ef       	ldi	r24, 0xF0	; 240
     a1e:	8b bd       	out	0x2b, r24	; 43
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/USI_TWI_Slave.c:200
          (0x0 << USICNT0); // Set USI to sample 8 bits i.e. count 16 external pin toggles.
}
     a20:	8f 91       	pop	r24
     a22:	0f 90       	pop	r0
     a24:	0f be       	out	0x3f, r0	; 63
     a26:	0f 90       	pop	r0
     a28:	1f 90       	pop	r1
     a2a:	18 95       	reti

00000a2c <DS3231_get_addr(unsigned char) [clone .constprop.10]>:
_Z15DS3231_get_addrh.constprop.10():
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/ds3231.cpp:152
}

uint8_t DS3231_get_addr(const uint8_t addr)
     a2c:	cf 92       	push	r12
     a2e:	df 92       	push	r13
     a30:	ef 92       	push	r14
     a32:	ff 92       	push	r15
     a34:	cf 93       	push	r28
beginTransmission():
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/Wire.cpp:462
     a36:	88 e6       	ldi	r24, 0x68	; 104
     a38:	0e 94 7d 00 	call	0xfa	; 0xfa <TwoWire::beginTransmission(unsigned char) [clone .constprop.21]>
_Z15DS3231_get_addrh.constprop.10():
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/ds3231.cpp:157
{
    uint8_t rv;

    Wire.beginTransmission(DS3231_I2C_ADDR);
    Wire.write(addr);
     a3c:	8f e0       	ldi	r24, 0x0F	; 15
     a3e:	0e 94 88 00 	call	0x110	; 0x110 <TwoWire::write(unsigned char) [clone .constprop.17]>
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/ds3231.cpp:158
    Wire.endTransmission();
     a42:	0e 94 4a 03 	call	0x694	; 0x694 <TwoWire::endTransmission() [clone .constprop.18]>
millis():
C:\Users\táta\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\cores\tinymodern/wiring.c:117
}

unsigned long millis()
{
  unsigned long m;
  uint8_t oldSREG = SREG;
     a46:	8f b7       	in	r24, 0x3f	; 63
C:\Users\táta\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\cores\tinymodern/wiring.c:121

  // disable interrupts while we read millis_timer_millis or we might get an
  // inconsistent value (e.g. in the middle of a write to millis_timer_millis)
  cli();
     a48:	f8 94       	cli
C:\Users\táta\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\cores\tinymodern/wiring.c:122
  m = millis_timer_millis;
     a4a:	c0 90 57 01 	lds	r12, 0x0157	; 0x800157 <millis_timer_millis>
     a4e:	d0 90 58 01 	lds	r13, 0x0158	; 0x800158 <millis_timer_millis+0x1>
     a52:	e0 90 59 01 	lds	r14, 0x0159	; 0x800159 <millis_timer_millis+0x2>
     a56:	f0 90 5a 01 	lds	r15, 0x015A	; 0x80015a <millis_timer_millis+0x3>
C:\Users\táta\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\cores\tinymodern/wiring.c:123
  SREG = oldSREG;
     a5a:	8f bf       	out	0x3f, r24	; 63
requestFrom():
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/Wire.cpp:417
  // clamp to buffer length
  if (quantity > TWI_BUFFER_SIZE) {
    quantity = TWI_BUFFER_SIZE;
  }
  // set address of targeted slave and read mode
  Buffer[0] = (address << TWI_ADR_BITS) | (1 << TWI_READ_BIT);
     a5c:	c1 ed       	ldi	r28, 0xD1	; 209
millis():
C:\Users\táta\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\cores\tinymodern/wiring.c:117
}

unsigned long millis()
{
  unsigned long m;
  uint8_t oldSREG = SREG;
     a5e:	2f b7       	in	r18, 0x3f	; 63
C:\Users\táta\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\cores\tinymodern/wiring.c:121

  // disable interrupts while we read millis_timer_millis or we might get an
  // inconsistent value (e.g. in the middle of a write to millis_timer_millis)
  cli();
     a60:	f8 94       	cli
C:\Users\táta\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\cores\tinymodern/wiring.c:122
  m = millis_timer_millis;
     a62:	80 91 57 01 	lds	r24, 0x0157	; 0x800157 <millis_timer_millis>
     a66:	90 91 58 01 	lds	r25, 0x0158	; 0x800158 <millis_timer_millis+0x1>
     a6a:	a0 91 59 01 	lds	r26, 0x0159	; 0x800159 <millis_timer_millis+0x2>
     a6e:	b0 91 5a 01 	lds	r27, 0x015A	; 0x80015a <millis_timer_millis+0x3>
C:\Users\táta\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\cores\tinymodern/wiring.c:123
  SREG = oldSREG;
     a72:	2f bf       	out	0x3f, r18	; 63
_Z15DS3231_get_addrh.constprop.10():
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/ds3231.cpp:162

	uint8_t gotData = false;
	uint32_t start = millis(); // start timeout
	while(millis()-start < DS3231_TRANSACTION_TIMEOUT){
     a74:	8c 19       	sub	r24, r12
     a76:	9d 09       	sbc	r25, r13
     a78:	ae 09       	sbc	r26, r14
     a7a:	bf 09       	sbc	r27, r15
     a7c:	84 36       	cpi	r24, 0x64	; 100
     a7e:	91 05       	cpc	r25, r1
     a80:	a1 05       	cpc	r26, r1
     a82:	b1 05       	cpc	r27, r1
     a84:	08 f5       	brcc	.+66     	; 0xac8 <DS3231_get_addr(unsigned char) [clone .constprop.10]+0x9c>
requestFrom():
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/Wire.cpp:417
     a86:	c0 93 04 01 	sts	0x0104, r28	; 0x800104 <__data_end>
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/Wire.cpp:420
  // perform blocking read into buffer
  uint8_t ret = USI_TWI_Start_Transceiver_With_Data_Stop(Buffer, quantity,
                                                         sendStop);
     a8a:	41 e0       	ldi	r20, 0x01	; 1
     a8c:	62 e0       	ldi	r22, 0x02	; 2
     a8e:	84 e0       	ldi	r24, 0x04	; 4
     a90:	91 e0       	ldi	r25, 0x01	; 1
     a92:	0e 94 d2 02 	call	0x5a4	; 0x5a4 <USI_TWI_Start_Transceiver_With_Data_Stop>
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/Wire.cpp:422
  // set rx buffer iterator vars
  BufferIndex = 1; // ignore slave address
     a96:	91 e0       	ldi	r25, 0x01	; 1
     a98:	90 93 61 01 	sts	0x0161, r25	; 0x800161 <TwoWire::BufferIndex>
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/Wire.cpp:424
  // check for error
  if (ret == FALSE) {
     a9c:	81 11       	cpse	r24, r1
     a9e:	09 c0       	rjmp	.+18     	; 0xab2 <DS3231_get_addr(unsigned char) [clone .constprop.10]+0x86>
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/Wire.cpp:425
    BufferLength = BufferIndex;
     aa0:	90 93 60 01 	sts	0x0160, r25	; 0x800160 <TwoWire::BufferLength>
_Z15DS3231_get_addrh.constprop.10():
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/ds3231.cpp:167
	  if (Wire.requestFrom(DS3231_I2C_ADDR, 1) == 1) {
      	gotData = true;
      	break;
      }
      delay(2);
     aa4:	62 e0       	ldi	r22, 0x02	; 2
     aa6:	70 e0       	ldi	r23, 0x00	; 0
     aa8:	80 e0       	ldi	r24, 0x00	; 0
     aaa:	90 e0       	ldi	r25, 0x00	; 0
     aac:	0e 94 8e 02 	call	0x51c	; 0x51c <delay>
     ab0:	d6 cf       	rjmp	.-84     	; 0xa5e <DS3231_get_addr(unsigned char) [clone .constprop.10]+0x32>
requestFrom():
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/Wire.cpp:428
    return 0;
  }
  BufferLength = quantity;
     ab2:	82 e0       	ldi	r24, 0x02	; 2
     ab4:	80 93 60 01 	sts	0x0160, r24	; 0x800160 <TwoWire::BufferLength>
_Z15DS3231_get_addrh.constprop.10():
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/ds3231.cpp:172
    }
	if (!gotData)
    	return 0; // error timeout

    rv = Wire.read();
     ab8:	0e 94 bb 00 	call	0x176	; 0x176 <TwoWire::read() [clone .constprop.12]>
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/ds3231.cpp:175

    return rv;
}
     abc:	cf 91       	pop	r28
     abe:	ff 90       	pop	r15
     ac0:	ef 90       	pop	r14
     ac2:	df 90       	pop	r13
     ac4:	cf 90       	pop	r12
     ac6:	08 95       	ret
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/ds3231.cpp:170
      	break;
      }
      delay(2);
    }
	if (!gotData)
    	return 0; // error timeout
     ac8:	80 e0       	ldi	r24, 0x00	; 0
     aca:	f8 cf       	rjmp	.-16     	; 0xabc <DS3231_get_addr(unsigned char) [clone .constprop.10]+0x90>

00000acc <main>:
main():
C:\Users\táta\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\cores\tinymodern/main.cpp:13

#warning "This is the CLOCKWISE pin mapping - make sure you're using the pinout diagram with the pins in clockwise order"
#endif
#endif
int main(void)
{
     acc:	cf 93       	push	r28
     ace:	df 93       	push	r29
     ad0:	cd b7       	in	r28, 0x3d	; 61
     ad2:	de b7       	in	r29, 0x3e	; 62
     ad4:	2a 97       	sbiw	r28, 0x0a	; 10
     ad6:	0f b6       	in	r0, 0x3f	; 63
     ad8:	f8 94       	cli
     ada:	de bf       	out	0x3e, r29	; 62
     adc:	0f be       	out	0x3f, r0	; 63
     ade:	cd bf       	out	0x3d, r28	; 61
init():
C:\Users\táta\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\cores\tinymodern/wiring.c:491
  #else
  CLKPR=1<<CLKPCE; //enable change of protected register
  #endif
  CLKPR=1; //prescale by 2 for 4MHz
  #endif
  sei();
     ae0:	78 94       	sei
Timer0_SetWaveformGenerationMode():
C:\Users\táta\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\cores\tinymodern/core_timers.h:677
}
timer0_wgm_t;

__attribute__((always_inline)) static inline void Timer0_SetWaveformGenerationMode( timer0_wgm_t wgm )
{
  TCCR0A = (TCCR0A & ~MASK2(WGM01,WGM00)) | (((wgm & B011) >> 0) << WGM00);
     ae2:	8b b3       	in	r24, 0x1b	; 27
     ae4:	83 60       	ori	r24, 0x03	; 3
     ae6:	8b bb       	out	0x1b, r24	; 27
C:\Users\táta\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\cores\tinymodern/core_timers.h:678
  TCCR0B = (TCCR0B & ~MASK1(WGM02))       | (((wgm & B100) >> 2) << WGM02);
     ae8:	d3 98       	cbi	0x1a, 3	; 26
Timer0_ClockSelect():
C:\Users\táta\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\cores\tinymodern/core_timers.h:659
}
timer0_cs_t;

__attribute__((always_inline)) static inline void Timer0_ClockSelect( timer0_cs_t cs )
{
  TCCR0B = (TCCR0B & ~MASK3(CS02,CS01,CS00)) | (cs << CS00);
     aea:	8a b3       	in	r24, 0x1a	; 26
     aec:	88 7f       	andi	r24, 0xF8	; 248
     aee:	83 60       	ori	r24, 0x03	; 3
     af0:	8a bb       	out	0x1a, r24	; 26
Timer0_EnableOverflowInterrupt():
C:\Users\táta\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\cores\tinymodern/core_timers.h:733
  TIMSK |= (1<<OCIE0A);
}

__attribute__((always_inline)) static inline void Timer0_EnableOverflowInterrupt( void )
{
  TIMSK |= (1<<TOIE0);
     af2:	8a b7       	in	r24, 0x3a	; 58
     af4:	82 60       	ori	r24, 0x02	; 2
     af6:	8a bf       	out	0x3a, r24	; 58
Timer1_ClockSelect():
C:\Users\táta\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\cores\tinymodern/core_timers.h:811
}
timer1_cs_t;

__attribute__((always_inline)) static inline void Timer1_ClockSelect( timer1_cs_t cs )
{
  TCCR1B = (TCCR1B & ~MASK3(CS12,CS11,CS10)) | (cs << CS10);
     af8:	80 91 71 00 	lds	r24, 0x0071	; 0x800071 <__EEPROM_REGION_LENGTH__+0x7f0071>
     afc:	88 7f       	andi	r24, 0xF8	; 248
     afe:	80 93 71 00 	sts	0x0071, r24	; 0x800071 <__EEPROM_REGION_LENGTH__+0x7f0071>
Timer1_SetWaveformGenerationMode():
C:\Users\táta\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\cores\tinymodern/core_timers.h:837
}
timer1_wgm_t;

__attribute__((always_inline)) static inline void Timer1_SetWaveformGenerationMode( timer1_wgm_t wgm )
{
  TCCR1A = (TCCR1A & ~MASK2(WGM11,WGM10)) | (((wgm & B0011) >> 0) << WGM10);
     b02:	80 91 72 00 	lds	r24, 0x0072	; 0x800072 <__EEPROM_REGION_LENGTH__+0x7f0072>
     b06:	8c 7f       	andi	r24, 0xFC	; 252
     b08:	81 60       	ori	r24, 0x01	; 1
     b0a:	80 93 72 00 	sts	0x0072, r24	; 0x800072 <__EEPROM_REGION_LENGTH__+0x7f0072>
C:\Users\táta\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\cores\tinymodern/core_timers.h:838
  TCCR1B = (TCCR1B & ~MASK2(WGM13,WGM12)) | (((wgm & B1100) >> 2) << WGM12);
     b0e:	80 91 71 00 	lds	r24, 0x0071	; 0x800071 <__EEPROM_REGION_LENGTH__+0x7f0071>
     b12:	87 7e       	andi	r24, 0xE7	; 231
     b14:	80 93 71 00 	sts	0x0071, r24	; 0x800071 <__EEPROM_REGION_LENGTH__+0x7f0071>
Timer1_ClockSelect():
C:\Users\táta\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\cores\tinymodern/core_timers.h:811
}
timer1_cs_t;

__attribute__((always_inline)) static inline void Timer1_ClockSelect( timer1_cs_t cs )
{
  TCCR1B = (TCCR1B & ~MASK3(CS12,CS11,CS10)) | (cs << CS10);
     b18:	80 91 71 00 	lds	r24, 0x0071	; 0x800071 <__EEPROM_REGION_LENGTH__+0x7f0071>
     b1c:	88 7f       	andi	r24, 0xF8	; 248
     b1e:	83 60       	ori	r24, 0x03	; 3
     b20:	80 93 71 00 	sts	0x0071, r24	; 0x800071 <__EEPROM_REGION_LENGTH__+0x7f0071>
ADC_PrescalerSelect():
C:\Users\táta\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\cores\tinymodern/core_adc.h:89
}
adc_ps_t;

__attribute__((always_inline)) static inline void ADC_PrescalerSelect( adc_ps_t ps )
{
  ADCSRA = (ADCSRA & ~MASK3(ADPS2,ADPS1,ADPS0)) | (ps << ADPS0);
     b24:	83 b1       	in	r24, 0x03	; 3
     b26:	88 7f       	andi	r24, 0xF8	; 248
     b28:	86 60       	ori	r24, 0x06	; 6
     b2a:	83 b9       	out	0x03, r24	; 3
ADC_Enable():
C:\Users\táta\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\cores\tinymodern/core_adc.h:94
}

__attribute__((always_inline)) static inline void ADC_Enable( void )
{
  ADCSRA |= MASK1( ADEN );
     b2c:	1f 9a       	sbi	0x03, 7	; 3
setup():
C:\GitHub\Servoventil\FW\servoventil_1.0.0/servoventil_1.0.0.ino:166
}//konec void 
  
//******************************************************************************************************************************

void setup() { // nastavenÃ­
  pinMode(PWR_ON_PIN,OUTPUT);         // pin pro samodrÅ¾enÃ­ napÃ¡jenÃ­ CPU
     b2e:	61 e0       	ldi	r22, 0x01	; 1
     b30:	84 e0       	ldi	r24, 0x04	; 4
     b32:	0e 94 b5 01 	call	0x36a	; 0x36a <pinMode>
C:\GitHub\Servoventil\FW\servoventil_1.0.0/servoventil_1.0.0.ino:167
  pinMode(PWR_SERVO_ON_PIN,OUTPUT);   // pin pro napÃ¡jenÃ­ serva
     b36:	61 e0       	ldi	r22, 0x01	; 1
     b38:	82 e0       	ldi	r24, 0x02	; 2
     b3a:	0e 94 b5 01 	call	0x36a	; 0x36a <pinMode>
C:\GitHub\Servoventil\FW\servoventil_1.0.0/servoventil_1.0.0.ino:168
  pinMode(SERVO_PIN,OUTPUT);          // pin pro PWM serva
     b3e:	61 e0       	ldi	r22, 0x01	; 1
     b40:	83 e0       	ldi	r24, 0x03	; 3
     b42:	0e 94 b5 01 	call	0x36a	; 0x36a <pinMode>
C:\GitHub\Servoventil\FW\servoventil_1.0.0/servoventil_1.0.0.ino:169
  pinMode(LED_LOWBAT_PIN,OUTPUT);     // pin pro LED
     b46:	61 e0       	ldi	r22, 0x01	; 1
     b48:	86 e0       	ldi	r24, 0x06	; 6
     b4a:	0e 94 b5 01 	call	0x36a	; 0x36a <pinMode>
C:\GitHub\Servoventil\FW\servoventil_1.0.0/servoventil_1.0.0.ino:170
  pinMode(LOW_BAT_PIN,INPUT);         // pin na AD
     b4e:	60 e0       	ldi	r22, 0x00	; 0
     b50:	80 e4       	ldi	r24, 0x40	; 64
     b52:	0e 94 b5 01 	call	0x36a	; 0x36a <pinMode>
C:\GitHub\Servoventil\FW\servoventil_1.0.0/servoventil_1.0.0.ino:171
  pinMode(SW1_PIN,INPUT_PULLUP);      // pin DIP1 
     b56:	62 e0       	ldi	r22, 0x02	; 2
     b58:	87 e0       	ldi	r24, 0x07	; 7
     b5a:	0e 94 b5 01 	call	0x36a	; 0x36a <pinMode>
C:\GitHub\Servoventil\FW\servoventil_1.0.0/servoventil_1.0.0.ino:172
  pinMode(SW2_PIN,INPUT_PULLUP);      // pin DIP2
     b5e:	62 e0       	ldi	r22, 0x02	; 2
     b60:	88 e0       	ldi	r24, 0x08	; 8
     b62:	0e 94 b5 01 	call	0x36a	; 0x36a <pinMode>
C:\GitHub\Servoventil\FW\servoventil_1.0.0/servoventil_1.0.0.ino:173
  pinMode(SW3_PIN,INPUT_PULLUP);      // pin DIP3
     b66:	62 e0       	ldi	r22, 0x02	; 2
     b68:	89 e0       	ldi	r24, 0x09	; 9
     b6a:	0e 94 b5 01 	call	0x36a	; 0x36a <pinMode>
C:\GitHub\Servoventil\FW\servoventil_1.0.0/servoventil_1.0.0.ino:174
  pinMode(SW4_PIN,INPUT_PULLUP);      // pin DIP4
     b6e:	62 e0       	ldi	r22, 0x02	; 2
     b70:	8a e0       	ldi	r24, 0x0A	; 10
     b72:	0e 94 b5 01 	call	0x36a	; 0x36a <pinMode>
C:\GitHub\Servoventil\FW\servoventil_1.0.0/servoventil_1.0.0.ino:176
  
  digitalWrite(PWR_ON_PIN,HIGH);      // podrÅ¾et napÃ¡jenÃ­ (po uvolnÄnÃ­ tlaÄÃ­tka)
     b76:	61 e0       	ldi	r22, 0x01	; 1
     b78:	84 e0       	ldi	r24, 0x04	; 4
     b7a:	0e 94 6a 01 	call	0x2d4	; 0x2d4 <digitalWrite>
C:\GitHub\Servoventil\FW\servoventil_1.0.0/servoventil_1.0.0.ino:178
  
  digitalWrite(PWR_SERVO_ON_PIN,LOW); // vypnout napÃ¡jenÃ­ serva
     b7e:	60 e0       	ldi	r22, 0x00	; 0
     b80:	82 e0       	ldi	r24, 0x02	; 2
     b82:	0e 94 6a 01 	call	0x2d4	; 0x2d4 <digitalWrite>
C:\GitHub\Servoventil\FW\servoventil_1.0.0/servoventil_1.0.0.ino:179
  digitalWrite(SERVO_PIN,LOW);        // vypnout vÃ½stup pro PWM serva      
     b86:	60 e0       	ldi	r22, 0x00	; 0
     b88:	83 e0       	ldi	r24, 0x03	; 3
     b8a:	0e 94 6a 01 	call	0x2d4	; 0x2d4 <digitalWrite>
C:\GitHub\Servoventil\FW\servoventil_1.0.0/servoventil_1.0.0.ino:180
  digitalWrite(LED_LOWBAT_PIN,HIGH);  // zapnout LED
     b8e:	61 e0       	ldi	r22, 0x01	; 1
     b90:	86 e0       	ldi	r24, 0x06	; 6
     b92:	0e 94 6a 01 	call	0x2d4	; 0x2d4 <digitalWrite>
wdt_enable():
c:\users\táta\appdata\local\arduino15\packages\arduino\tools\avr-gcc\7.3.0-atmel3.6.1-arduino5\avr\include\avr/wdt.h:354
			[SIGNATURE] "r" ((uint8_t)0xD8),
			[WDTREG] "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)),
			[WDVALUE] "r" ((uint8_t)((value & 0x08 ? _WD_PS3_MASK : 0x00)
				| _BV(WDE) | (value & 0x07) ))
			: "r0"
			);
     b96:	88 ed       	ldi	r24, 0xD8	; 216
     b98:	98 e2       	ldi	r25, 0x28	; 40
     b9a:	0f b6       	in	r0, 0x3f	; 63
     b9c:	f8 94       	cli
     b9e:	a8 95       	wdr
     ba0:	8f bd       	out	0x2f, r24	; 47
     ba2:	90 bf       	out	0x30, r25	; 48
     ba4:	0f be       	out	0x3f, r0	; 63
setup():
C:\GitHub\Servoventil\FW\servoventil_1.0.0/servoventil_1.0.0.ino:183

  wdt_enable(WDTO_4S);                // povolit watchdog ping 4s
  wdt_reset();                        // vynulovat ÄasovaÄ pro wdt
     ba6:	a8 95       	wdr
C:\GitHub\Servoventil\FW\servoventil_1.0.0/servoventil_1.0.0.ino:189
  
  #ifdef USE_UART
     Serial.begin(BAUD);              // rychlost linky 
     delay(1000);                     // poÄkÃ¡me na UART
  #endif
  wdt_reset();                        // vynulovat ÄasovaÄ pro wdt
     ba8:	a8 95       	wdr
begin():
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/Wire.cpp:362
}

// Public Methods //////////////////////////////////////////////////////////////

void TwoWire::begin(void) {
  BufferIndex = 0;
     baa:	10 92 61 01 	sts	0x0161, r1	; 0x800161 <TwoWire::BufferIndex>
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/Wire.cpp:363
  BufferLength = 0;
     bae:	10 92 60 01 	sts	0x0160, r1	; 0x800160 <TwoWire::BufferLength>
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/Wire.cpp:365

  transmitting = 0;
     bb2:	10 92 62 01 	sts	0x0162, r1	; 0x800162 <TwoWire::transmitting>
USI_TWI_Master_Initialise():
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/USI_TWI_Master.c:56
/*---------------------------------------------------------------
 USI TWI single master initialization function
---------------------------------------------------------------*/
void USI_TWI_Master_Initialise(void)
{
  PORT_USI |= (1 << PIN_USI_SDA); // Enable pullup on SDA, to set high as released state.
     bb6:	69 9a       	sbi	0x0d, 1	; 13
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/USI_TWI_Master.c:57
  PORT_USI_CL |= (1 << PIN_USI_SCL); // Enable pullup on SCL, to set high as released state.
     bb8:	49 9a       	sbi	0x09, 1	; 9
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/USI_TWI_Master.c:59

  DDR_USI_CL |= (1 << PIN_USI_SCL); // Enable SCL as output.
     bba:	41 9a       	sbi	0x08, 1	; 8
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/USI_TWI_Master.c:60
  DDR_USI |= (1 << PIN_USI_SDA); // Enable SDA as output.
     bbc:	61 9a       	sbi	0x0c, 1	; 12
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/USI_TWI_Master.c:62

  USIDR = 0xFF;                                           // Preload dataregister with "released level" data.
     bbe:	8f ef       	ldi	r24, 0xFF	; 255
     bc0:	8c bd       	out	0x2c, r24	; 44
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/USI_TWI_Master.c:63
  USICR = (0 << USISIE) | (0 << USIOIE) |                 // Disable Interrupts.
     bc2:	8a e2       	ldi	r24, 0x2A	; 42
     bc4:	8a bd       	out	0x2a, r24	; 42
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/USI_TWI_Master.c:67
          (1 << USIWM1) | (0 << USIWM0) |                 // Set USI in Two-wire mode.
          (1 << USICS1) | (0 << USICS0) | (1 << USICLK) | // Software stobe as counter clock source
          (0 << USITC);
  USISR = (1 << USISIF) | (1 << USIOIF) | (1 << USIPF) | (1 << USIDC) | // Clear flags,
     bc6:	80 ef       	ldi	r24, 0xF0	; 240
     bc8:	8b bd       	out	0x2b, r24	; 43
beginTransmission():
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/Wire.cpp:462
  BufferIndex = 1; // reserved by slave address
  BufferLength = BufferIndex;
}

void TwoWire::beginTransmission(int address) {
  beginTransmission((uint8_t)address);
     bca:	88 e6       	ldi	r24, 0x68	; 104
     bcc:	0e 94 7d 00 	call	0xfa	; 0xfa <TwoWire::beginTransmission(unsigned char) [clone .constprop.21]>
setup():
C:\GitHub\Servoventil\FW\servoventil_1.0.0/servoventil_1.0.0.ino:217
  #ifdef USE_DS3231 
    #ifdef DEBUG
       DPRINT("RTC init...");
    #endif                                     
    Wire.beginTransmission(DS_ADDRESS);           // probuÄ zaÅÃ­zenÃ­ na 0x68
    if(Wire.endTransmission()==0) {               // test zda byla odpovÄÄ ze zaÅÃ­zenÃ­ na adrese 0x68 (RTC DS3231)
     bd0:	0e 94 4a 03 	call	0x694	; 0x694 <TwoWire::endTransmission() [clone .constprop.18]>
     bd4:	81 11       	cpse	r24, r1
     bd6:	12 c0       	rjmp	.+36     	; 0xbfc <main+0x130>
DS3231_set_creg():
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/ds3231.cpp:183

// control register

void DS3231_set_creg(const uint8_t val)
{
    DS3231_set_addr(DS3231_CONTROL_ADDR, val);
     bd8:	64 e0       	ldi	r22, 0x04	; 4
     bda:	8e e0       	ldi	r24, 0x0E	; 14
     bdc:	0e 94 6b 03 	call	0x6d6	; 0x6d6 <DS3231_set_addr(unsigned char, unsigned char)>
DS3231_get_sreg():
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/ds3231.cpp:211
}

uint8_t DS3231_get_sreg(void)
{
    uint8_t rv;
    rv = DS3231_get_addr(DS3231_STATUS_ADDR);
     be0:	0e 94 16 05 	call	0xa2c	; 0xa2c <DS3231_get_addr(unsigned char) [clone .constprop.10]>
DS3231_set_32kHz_output():
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/ds3231.cpp:303
        sreg &= ~DS3231_STATUS_OSF;
        sreg |= DS3231_STATUS_EN32KHZ;
        DS3231_set_sreg(sreg);
    } else {
        uint8_t sreg = DS3231_get_sreg();
        sreg &= ~DS3231_STATUS_EN32KHZ;
     be4:	68 2f       	mov	r22, r24
     be6:	67 7f       	andi	r22, 0xF7	; 247
DS3231_set_sreg():
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/ds3231.cpp:205
bit0 A1F      Alarm 1 Flag - (1 if alarm1 was triggered)
*/

void DS3231_set_sreg(const uint8_t val)
{
    DS3231_set_addr(DS3231_STATUS_ADDR, val);
     be8:	8f e0       	ldi	r24, 0x0F	; 15
     bea:	0e 94 6b 03 	call	0x6d6	; 0x6d6 <DS3231_set_addr(unsigned char, unsigned char)>
DS3231_get_sreg():
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/ds3231.cpp:211
}

uint8_t DS3231_get_sreg(void)
{
    uint8_t rv;
    rv = DS3231_get_addr(DS3231_STATUS_ADDR);
     bee:	0e 94 16 05 	call	0xa2c	; 0xa2c <DS3231_get_addr(unsigned char) [clone .constprop.10]>
DS3231_clear_a2f():
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/ds3231.cpp:447
// when the alarm flag is cleared the pulldown on INT is also released
void DS3231_clear_a2f(void)
{
    uint8_t reg_val;

    reg_val = DS3231_get_sreg() & ~DS3231_STATUS_A2F;
     bf2:	68 2f       	mov	r22, r24
     bf4:	6d 7f       	andi	r22, 0xFD	; 253
DS3231_set_sreg():
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/ds3231.cpp:205
bit0 A1F      Alarm 1 Flag - (1 if alarm1 was triggered)
*/

void DS3231_set_sreg(const uint8_t val)
{
    DS3231_set_addr(DS3231_STATUS_ADDR, val);
     bf6:	8f e0       	ldi	r24, 0x0F	; 15
     bf8:	0e 94 6b 03 	call	0x6d6	; 0x6d6 <DS3231_set_addr(unsigned char, unsigned char)>
read_DIP():
C:\GitHub\Servoventil\FW\servoventil_1.0.0/servoventil_1.0.0.ino:118
   #endif
 #endif
}//konec void    

void read_DIP(){
   ZapNaDobu = 0;                            // doba 1-7 minut dle DIP
     bfc:	10 92 2f 01 	sts	0x012F, r1	; 0x80012f <ZapNaDobu>
C:\GitHub\Servoventil\FW\servoventil_1.0.0/servoventil_1.0.0.ino:119
   if(!digitalRead(SW1_PIN)) ZapNaDobu  = 1; // 1 minuta
     c00:	87 e0       	ldi	r24, 0x07	; 7
     c02:	0e 94 50 01 	call	0x2a0	; 0x2a0 <digitalRead>
     c06:	89 2b       	or	r24, r25
     c08:	19 f4       	brne	.+6      	; 0xc10 <main+0x144>
     c0a:	81 e0       	ldi	r24, 0x01	; 1
     c0c:	80 93 2f 01 	sts	0x012F, r24	; 0x80012f <ZapNaDobu>
C:\GitHub\Servoventil\FW\servoventil_1.0.0/servoventil_1.0.0.ino:120
   if(!digitalRead(SW2_PIN)) ZapNaDobu += 2; // 2 minuty
     c10:	88 e0       	ldi	r24, 0x08	; 8
     c12:	0e 94 50 01 	call	0x2a0	; 0x2a0 <digitalRead>
     c16:	89 2b       	or	r24, r25
     c18:	29 f4       	brne	.+10     	; 0xc24 <main+0x158>
     c1a:	80 91 2f 01 	lds	r24, 0x012F	; 0x80012f <ZapNaDobu>
     c1e:	8e 5f       	subi	r24, 0xFE	; 254
     c20:	80 93 2f 01 	sts	0x012F, r24	; 0x80012f <ZapNaDobu>
C:\GitHub\Servoventil\FW\servoventil_1.0.0/servoventil_1.0.0.ino:121
   if(!digitalRead(SW3_PIN)) ZapNaDobu += 4; // 4 minuty
     c24:	89 e0       	ldi	r24, 0x09	; 9
     c26:	0e 94 50 01 	call	0x2a0	; 0x2a0 <digitalRead>
     c2a:	89 2b       	or	r24, r25
     c2c:	29 f4       	brne	.+10     	; 0xc38 <main+0x16c>
     c2e:	80 91 2f 01 	lds	r24, 0x012F	; 0x80012f <ZapNaDobu>
     c32:	8c 5f       	subi	r24, 0xFC	; 252
     c34:	80 93 2f 01 	sts	0x012F, r24	; 0x80012f <ZapNaDobu>
C:\GitHub\Servoventil\FW\servoventil_1.0.0/servoventil_1.0.0.ino:123
   
   if(!digitalRead(SW4_PIN)) hod_interval = true;
     c38:	8a e0       	ldi	r24, 0x0A	; 10
     c3a:	0e 94 50 01 	call	0x2a0	; 0x2a0 <digitalRead>
     c3e:	89 2b       	or	r24, r25
     c40:	09 f0       	breq	.+2      	; 0xc44 <main+0x178>
     c42:	4c c0       	rjmp	.+152    	; 0xcdc <main+0x210>
     c44:	81 e0       	ldi	r24, 0x01	; 1
     c46:	80 93 2c 01 	sts	0x012C, r24	; 0x80012c <hod_interval>
C:\GitHub\Servoventil\FW\servoventil_1.0.0/servoventil_1.0.0.ino:126
   else                      hod_interval = false;

  if(hod_interval) { pocet_hodin = 23; pocet_minut = 59; } // 24 hodin interval
     c4a:	80 91 2c 01 	lds	r24, 0x012C	; 0x80012c <hod_interval>
     c4e:	88 23       	and	r24, r24
     c50:	09 f4       	brne	.+2      	; 0xc54 <main+0x188>
     c52:	47 c0       	rjmp	.+142    	; 0xce2 <main+0x216>
     c54:	87 e1       	ldi	r24, 0x17	; 23
     c56:	80 93 2e 01 	sts	0x012E, r24	; 0x80012e <pocet_hodin>
     c5a:	8b e3       	ldi	r24, 0x3B	; 59
     c5c:	80 93 2d 01 	sts	0x012D, r24	; 0x80012d <pocet_minut>
beginTransmission():
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/Wire.cpp:462
     c60:	88 e6       	ldi	r24, 0x68	; 104
     c62:	0e 94 7d 00 	call	0xfa	; 0xfa <TwoWire::beginTransmission(unsigned char) [clone .constprop.21]>
write():
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/Wire.h:138
    uint8_t isActive(void);

    inline size_t write(unsigned long n) { return write((uint8_t)n); }
    inline size_t write(long n) { return write((uint8_t)n); }
    inline size_t write(unsigned int n) { return write((uint8_t)n); }
    inline size_t write(int n) { return write((uint8_t)n); }
     c66:	80 e0       	ldi	r24, 0x00	; 0
     c68:	0e 94 88 00 	call	0x110	; 0x110 <TwoWire::write(unsigned char) [clone .constprop.17]>
DS3231_get():
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/ds3231.cpp:102
    uint8_t i, n;
    uint16_t year_full;

    Wire.beginTransmission(DS3231_I2C_ADDR);
    Wire.write(DS3231_TIME_CAL_ADDR);
    Wire.endTransmission();
     c6c:	0e 94 4a 03 	call	0x694	; 0x694 <TwoWire::endTransmission() [clone .constprop.18]>
millis():
C:\Users\táta\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\cores\tinymodern/wiring.c:117
}

unsigned long millis()
{
  unsigned long m;
  uint8_t oldSREG = SREG;
     c70:	8f b7       	in	r24, 0x3f	; 63
C:\Users\táta\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\cores\tinymodern/wiring.c:121

  // disable interrupts while we read millis_timer_millis or we might get an
  // inconsistent value (e.g. in the middle of a write to millis_timer_millis)
  cli();
     c72:	f8 94       	cli
C:\Users\táta\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\cores\tinymodern/wiring.c:122
  m = millis_timer_millis;
     c74:	80 90 57 01 	lds	r8, 0x0157	; 0x800157 <millis_timer_millis>
     c78:	90 90 58 01 	lds	r9, 0x0158	; 0x800158 <millis_timer_millis+0x1>
     c7c:	a0 90 59 01 	lds	r10, 0x0159	; 0x800159 <millis_timer_millis+0x2>
     c80:	b0 90 5a 01 	lds	r11, 0x015A	; 0x80015a <millis_timer_millis+0x3>
C:\Users\táta\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\cores\tinymodern/wiring.c:123
  SREG = oldSREG;
     c84:	8f bf       	out	0x3f, r24	; 63
requestFrom():
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/Wire.cpp:417
  // clamp to buffer length
  if (quantity > TWI_BUFFER_SIZE) {
    quantity = TWI_BUFFER_SIZE;
  }
  // set address of targeted slave and read mode
  Buffer[0] = (address << TWI_ADR_BITS) | (1 << TWI_READ_BIT);
     c86:	01 ed       	ldi	r16, 0xD1	; 209
millis():
C:\Users\táta\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\cores\tinymodern/wiring.c:117
}

unsigned long millis()
{
  unsigned long m;
  uint8_t oldSREG = SREG;
     c88:	2f b7       	in	r18, 0x3f	; 63
C:\Users\táta\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\cores\tinymodern/wiring.c:121

  // disable interrupts while we read millis_timer_millis or we might get an
  // inconsistent value (e.g. in the middle of a write to millis_timer_millis)
  cli();
     c8a:	f8 94       	cli
C:\Users\táta\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\cores\tinymodern/wiring.c:122
  m = millis_timer_millis;
     c8c:	80 91 57 01 	lds	r24, 0x0157	; 0x800157 <millis_timer_millis>
     c90:	90 91 58 01 	lds	r25, 0x0158	; 0x800158 <millis_timer_millis+0x1>
     c94:	a0 91 59 01 	lds	r26, 0x0159	; 0x800159 <millis_timer_millis+0x2>
     c98:	b0 91 5a 01 	lds	r27, 0x015A	; 0x80015a <millis_timer_millis+0x3>
C:\Users\táta\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\cores\tinymodern/wiring.c:123
  SREG = oldSREG;
     c9c:	2f bf       	out	0x3f, r18	; 63
DS3231_get():
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/ds3231.cpp:106

	uint8_t gotData = false;
	uint32_t start = millis(); // start timeout
	while(millis()-start < DS3231_TRANSACTION_TIMEOUT){
     c9e:	88 19       	sub	r24, r8
     ca0:	99 09       	sbc	r25, r9
     ca2:	aa 09       	sbc	r26, r10
     ca4:	bb 09       	sbc	r27, r11
     ca6:	84 36       	cpi	r24, 0x64	; 100
     ca8:	91 05       	cpc	r25, r1
     caa:	a1 05       	cpc	r26, r1
     cac:	b1 05       	cpc	r27, r1
     cae:	e0 f5       	brcc	.+120    	; 0xd28 <main+0x25c>
requestFrom():
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/Wire.cpp:417
     cb0:	00 93 04 01 	sts	0x0104, r16	; 0x800104 <__data_end>
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/Wire.cpp:420
  // perform blocking read into buffer
  uint8_t ret = USI_TWI_Start_Transceiver_With_Data_Stop(Buffer, quantity,
                                                         sendStop);
     cb4:	41 e0       	ldi	r20, 0x01	; 1
     cb6:	68 e0       	ldi	r22, 0x08	; 8
     cb8:	84 e0       	ldi	r24, 0x04	; 4
     cba:	91 e0       	ldi	r25, 0x01	; 1
     cbc:	0e 94 d2 02 	call	0x5a4	; 0x5a4 <USI_TWI_Start_Transceiver_With_Data_Stop>
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/Wire.cpp:422
  // set rx buffer iterator vars
  BufferIndex = 1; // ignore slave address
     cc0:	91 e0       	ldi	r25, 0x01	; 1
     cc2:	90 93 61 01 	sts	0x0161, r25	; 0x800161 <TwoWire::BufferIndex>
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/Wire.cpp:424
  // check for error
  if (ret == FALSE) {
     cc6:	81 11       	cpse	r24, r1
     cc8:	12 c0       	rjmp	.+36     	; 0xcee <main+0x222>
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/Wire.cpp:425
    BufferLength = BufferIndex;
     cca:	90 93 60 01 	sts	0x0160, r25	; 0x800160 <TwoWire::BufferLength>
DS3231_get():
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/ds3231.cpp:111
	  if (Wire.requestFrom(DS3231_I2C_ADDR, 7) == 7) {
      	gotData = true;
      	break;
      }
      delay(2);
     cce:	62 e0       	ldi	r22, 0x02	; 2
     cd0:	70 e0       	ldi	r23, 0x00	; 0
     cd2:	80 e0       	ldi	r24, 0x00	; 0
     cd4:	90 e0       	ldi	r25, 0x00	; 0
     cd6:	0e 94 8e 02 	call	0x51c	; 0x51c <delay>
     cda:	d6 cf       	rjmp	.-84     	; 0xc88 <main+0x1bc>
read_DIP():
C:\GitHub\Servoventil\FW\servoventil_1.0.0/servoventil_1.0.0.ino:124
   if(!digitalRead(SW1_PIN)) ZapNaDobu  = 1; // 1 minuta
   if(!digitalRead(SW2_PIN)) ZapNaDobu += 2; // 2 minuty
   if(!digitalRead(SW3_PIN)) ZapNaDobu += 4; // 4 minuty
   
   if(!digitalRead(SW4_PIN)) hod_interval = true;
   else                      hod_interval = false;
     cdc:	10 92 2c 01 	sts	0x012C, r1	; 0x80012c <hod_interval>
     ce0:	b4 cf       	rjmp	.-152    	; 0xc4a <main+0x17e>
C:\GitHub\Servoventil\FW\servoventil_1.0.0/servoventil_1.0.0.ino:127

  if(hod_interval) { pocet_hodin = 23; pocet_minut = 59; } // 24 hodin interval
  else             { pocet_hodin = 12; pocet_minut = 0;  } // 12 hodin interval
     ce2:	8c e0       	ldi	r24, 0x0C	; 12
     ce4:	80 93 2e 01 	sts	0x012E, r24	; 0x80012e <pocet_hodin>
     ce8:	10 92 2d 01 	sts	0x012D, r1	; 0x80012d <pocet_minut>
     cec:	b9 cf       	rjmp	.-142    	; 0xc60 <main+0x194>
requestFrom():
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/Wire.cpp:428
    return 0;
  }
  BufferLength = quantity;
     cee:	88 e0       	ldi	r24, 0x08	; 8
     cf0:	80 93 60 01 	sts	0x0160, r24	; 0x800160 <TwoWire::BufferLength>
     cf4:	ce 01       	movw	r24, r28
     cf6:	01 96       	adiw	r24, 0x01	; 1
     cf8:	7c 01       	movw	r14, r24
main():
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/ds3231.cpp:116
    }
	if (!gotData)
    	return; // error timeout
    
    for (i = 0; i <= 6; i++) {
     cfa:	10 e0       	ldi	r17, 0x00	; 0
DS3231_get():
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/ds3231.cpp:117
        n = Wire.read();
     cfc:	0e 94 bb 00 	call	0x176	; 0x176 <TwoWire::read() [clone .constprop.12]>
     d00:	98 2f       	mov	r25, r24
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/ds3231.cpp:118
        if (i == 5) {
     d02:	15 30       	cpi	r17, 0x05	; 5
     d04:	49 f0       	breq	.+18     	; 0xd18 <main+0x24c>
bcdtodec():
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/ds3231.cpp:496
    return ((val / 10 * 16) + (val % 10));
}

uint8_t bcdtodec(const uint8_t val)
{
    return ((val / 16 * 10) + (val % 16));
     d06:	82 95       	swap	r24
     d08:	8f 70       	andi	r24, 0x0F	; 15
     d0a:	6a e0       	ldi	r22, 0x0A	; 10
     d0c:	0e 94 d8 07 	call	0xfb0	; 0xfb0 <__mulqi3>
     d10:	9f 70       	andi	r25, 0x0F	; 15
     d12:	98 0f       	add	r25, r24
DS3231_get():
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/ds3231.cpp:122
        n = Wire.read();
        if (i == 5) {
            TimeDate[5] = bcdtodec(n & 0x1F);
            century = (n & 0x80) >> 7;
        } else
            TimeDate[i] = bcdtodec(n);
     d14:	f7 01       	movw	r30, r14
     d16:	90 83       	st	Z, r25
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/ds3231.cpp:116
      delay(2);
    }
	if (!gotData)
    	return; // error timeout
    
    for (i = 0; i <= 6; i++) {
     d18:	1f 5f       	subi	r17, 0xFF	; 255
     d1a:	ff ef       	ldi	r31, 0xFF	; 255
     d1c:	ef 1a       	sub	r14, r31
     d1e:	ff 0a       	sbc	r15, r31
     d20:	17 30       	cpi	r17, 0x07	; 7
     d22:	61 f7       	brne	.-40     	; 0xcfc <main+0x230>
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/ds3231.cpp:132
    } else {
        year_full = 1900 + TimeDate[6];
    }

    t->sec = TimeDate[0];
    t->min = TimeDate[1];
     d24:	1a 81       	ldd	r17, Y+2	; 0x02
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/ds3231.cpp:133
    t->hour = TimeDate[2];
     d26:	fb 80       	ldd	r15, Y+3	; 0x03
set_next_alarm():
C:\GitHub\Servoventil\FW\servoventil_1.0.0/servoventil_1.0.0.ino:144
  #ifdef USE_DS3231 
    struct ts t;
    unsigned char wakeup_hour, wakeup_min;
    DS3231_get(&t);
    
    wakeup_hour = (t.hour / pocet_hodin + 1) * pocet_hodin;
     d28:	20 91 2e 01 	lds	r18, 0x012E	; 0x80012e <pocet_hodin>
     d2c:	8f 2d       	mov	r24, r15
     d2e:	62 2f       	mov	r22, r18
     d30:	0e 94 f2 07 	call	0xfe4	; 0xfe4 <__udivmodqi4>
     d34:	8f 5f       	subi	r24, 0xFF	; 255
     d36:	0e 94 d8 07 	call	0xfb0	; 0xfb0 <__mulqi3>
     d3a:	28 2f       	mov	r18, r24
C:\GitHub\Servoventil\FW\servoventil_1.0.0/servoventil_1.0.0.ino:145
    if (wakeup_hour > 23) wakeup_hour -= 24; 
     d3c:	88 31       	cpi	r24, 0x18	; 24
     d3e:	08 f0       	brcs	.+2      	; 0xd42 <main+0x276>
     d40:	28 51       	subi	r18, 0x18	; 24
C:\GitHub\Servoventil\FW\servoventil_1.0.0/servoventil_1.0.0.ino:146
    wakeup_min = (t.min / pocet_minut + 1) * pocet_minut;
     d42:	30 91 2d 01 	lds	r19, 0x012D	; 0x80012d <pocet_minut>
     d46:	81 2f       	mov	r24, r17
     d48:	63 2f       	mov	r22, r19
     d4a:	0e 94 f2 07 	call	0xfe4	; 0xfe4 <__udivmodqi4>
     d4e:	8f 5f       	subi	r24, 0xFF	; 255
     d50:	0e 94 d8 07 	call	0xfb0	; 0xfb0 <__mulqi3>
C:\GitHub\Servoventil\FW\servoventil_1.0.0/servoventil_1.0.0.ino:147
    if (wakeup_min > 59) wakeup_min -= 60; 
     d54:	8c 33       	cpi	r24, 0x3C	; 60
     d56:	08 f0       	brcs	.+2      	; 0xd5a <main+0x28e>
     d58:	8c 53       	subi	r24, 0x3C	; 60
C:\GitHub\Servoventil\FW\servoventil_1.0.0/servoventil_1.0.0.ino:155
    // to trigger the alarm
    // A2M2 (minutes) (0 to enable, 1 to disable)
    // A2M3 (hour)    (0 to enable, 1 to disable) 
    // A2M4 (day)     (0 to enable, 1 to disable)
    // DY/DT          (dayofweek == 1/dayofmonth == 0)
    uint8_t flags[4] = { 0, 0, 1, 1 };
     d5a:	40 91 00 01 	lds	r20, 0x0100	; 0x800100 <__data_start>
     d5e:	50 91 01 01 	lds	r21, 0x0101	; 0x800101 <__data_start+0x1>
     d62:	60 91 02 01 	lds	r22, 0x0102	; 0x800102 <__data_start+0x2>
     d66:	70 91 03 01 	lds	r23, 0x0103	; 0x800103 <__data_start+0x3>
     d6a:	49 83       	std	Y+1, r20	; 0x01
     d6c:	5a 83       	std	Y+2, r21	; 0x02
     d6e:	6b 83       	std	Y+3, r22	; 0x03
     d70:	7c 83       	std	Y+4, r23	; 0x04
DS3231_set_a2():
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/ds3231.cpp:386
}

// flags are: A2M2 (minutes), A2M3 (hour), A2M4 (day) 0 to enable, 1 to disable, DY/DT (dayofweek == 1/dayofmonth == 0) - 
void DS3231_set_a2(const uint8_t mi, const uint8_t h, const uint8_t d, const uint8_t * flags)
{
    uint8_t t[3] = { mi, h, d };
     d72:	88 87       	std	Y+8, r24	; 0x08
     d74:	29 87       	std	Y+9, r18	; 0x09
     d76:	1a 86       	std	Y+10, r1	; 0x0a
beginTransmission():
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/Wire.cpp:462
  BufferIndex = 1; // reserved by slave address
  BufferLength = BufferIndex;
}

void TwoWire::beginTransmission(int address) {
  beginTransmission((uint8_t)address);
     d78:	88 e6       	ldi	r24, 0x68	; 104
     d7a:	0e 94 7d 00 	call	0xfa	; 0xfa <TwoWire::beginTransmission(unsigned char) [clone .constprop.21]>
write():
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/Wire.h:138
     d7e:	8b e0       	ldi	r24, 0x0B	; 11
     d80:	0e 94 88 00 	call	0x110	; 0x110 <TwoWire::write(unsigned char) [clone .constprop.17]>
     d84:	6e 01       	movw	r12, r28
     d86:	88 e0       	ldi	r24, 0x08	; 8
     d88:	c8 0e       	add	r12, r24
     d8a:	d1 1c       	adc	r13, r1
     d8c:	fe 01       	movw	r30, r28
     d8e:	31 96       	adiw	r30, 0x01	; 1
     d90:	7f 01       	movw	r14, r30
main():
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/ds3231.cpp:392
    uint8_t i;

    Wire.beginTransmission(DS3231_I2C_ADDR);
    Wire.write(DS3231_ALARM2_ADDR);

    for (i = 0; i <= 2; i++) {
     d92:	10 e0       	ldi	r17, 0x00	; 0
dectobcd():
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/ds3231.cpp:491
}
#endif

uint8_t dectobcd(const uint8_t val)
{
    return ((val / 10 * 16) + (val % 10));
     d94:	0a e0       	ldi	r16, 0x0A	; 10
write():
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/Wire.h:138
     d96:	80 ec       	ldi	r24, 0xC0	; 192
DS3231_set_a2():
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/ds3231.cpp:393

    Wire.beginTransmission(DS3231_I2C_ADDR);
    Wire.write(DS3231_ALARM2_ADDR);

    for (i = 0; i <= 2; i++) {
        if (i == 2) {
     d98:	12 30       	cpi	r17, 0x02	; 2
     d9a:	71 f0       	breq	.+28     	; 0xdb8 <main+0x2ec>
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/ds3231.cpp:396
            Wire.write(dectobcd(t[2]) | (flags[2] << 7) | (flags[3] << 6));
        } else
            Wire.write(dectobcd(t[i]) | (flags[i] << 7));
     d9c:	f6 01       	movw	r30, r12
     d9e:	80 81       	ld	r24, Z
dectobcd():
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/ds3231.cpp:491
}
#endif

uint8_t dectobcd(const uint8_t val)
{
    return ((val / 10 * 16) + (val % 10));
     da0:	60 2f       	mov	r22, r16
     da2:	0e 94 f2 07 	call	0xfe4	; 0xfe4 <__udivmodqi4>
     da6:	82 95       	swap	r24
     da8:	80 7f       	andi	r24, 0xF0	; 240
     daa:	98 0f       	add	r25, r24
DS3231_set_a2():
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/ds3231.cpp:396

    for (i = 0; i <= 2; i++) {
        if (i == 2) {
            Wire.write(dectobcd(t[2]) | (flags[2] << 7) | (flags[3] << 6));
        } else
            Wire.write(dectobcd(t[i]) | (flags[i] << 7));
     dac:	f7 01       	movw	r30, r14
     dae:	80 81       	ld	r24, Z
     db0:	87 95       	ror	r24
     db2:	88 27       	eor	r24, r24
     db4:	87 95       	ror	r24
write():
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/Wire.h:138
     db6:	89 2b       	or	r24, r25
     db8:	0e 94 88 00 	call	0x110	; 0x110 <TwoWire::write(unsigned char) [clone .constprop.17]>
DS3231_set_a2():
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/ds3231.cpp:392
    uint8_t i;

    Wire.beginTransmission(DS3231_I2C_ADDR);
    Wire.write(DS3231_ALARM2_ADDR);

    for (i = 0; i <= 2; i++) {
     dbc:	1f 5f       	subi	r17, 0xFF	; 255
     dbe:	ff ef       	ldi	r31, 0xFF	; 255
     dc0:	cf 1a       	sub	r12, r31
     dc2:	df 0a       	sbc	r13, r31
     dc4:	8f ef       	ldi	r24, 0xFF	; 255
     dc6:	e8 1a       	sub	r14, r24
     dc8:	f8 0a       	sbc	r15, r24
     dca:	13 30       	cpi	r17, 0x03	; 3
     dcc:	21 f7       	brne	.-56     	; 0xd96 <main+0x2ca>
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/ds3231.cpp:399
            Wire.write(dectobcd(t[2]) | (flags[2] << 7) | (flags[3] << 6));
        } else
            Wire.write(dectobcd(t[i]) | (flags[i] << 7));
    }

    Wire.endTransmission();
     dce:	0e 94 4a 03 	call	0x694	; 0x694 <TwoWire::endTransmission() [clone .constprop.18]>
DS3231_set_creg():
C:\Users\TTA~1\AppData\Local\Temp\arduino_build_966486\sketch/ds3231.cpp:183

// control register

void DS3231_set_creg(const uint8_t val)
{
    DS3231_set_addr(DS3231_CONTROL_ADDR, val);
     dd2:	66 e0       	ldi	r22, 0x06	; 6
     dd4:	8e e0       	ldi	r24, 0x0E	; 14
     dd6:	0e 94 6b 03 	call	0x6d6	; 0x6d6 <DS3231_set_addr(unsigned char, unsigned char)>
setup():
C:\GitHub\Servoventil\FW\servoventil_1.0.0/servoventil_1.0.0.ino:272
     #ifdef DEBUG
        DPRINTLN("Servo init...");
     #endif

     // OTEVRIT
     pinMode(PWR_SERVO_ON_PIN,OUTPUT);      // napÃ¡jenÃ­ serva vÃ½stupnÃ­ pin
     dda:	61 e0       	ldi	r22, 0x01	; 1
     ddc:	82 e0       	ldi	r24, 0x02	; 2
     dde:	0e 94 b5 01 	call	0x36a	; 0x36a <pinMode>
C:\GitHub\Servoventil\FW\servoventil_1.0.0/servoventil_1.0.0.ino:273
     digitalWrite(PWR_SERVO_ON_PIN, HIGH);  // zapnout napÃ¡jenÃ­ serva
     de2:	61 e0       	ldi	r22, 0x01	; 1
     de4:	82 e0       	ldi	r24, 0x02	; 2
     de6:	0e 94 6a 01 	call	0x2d4	; 0x2d4 <digitalWrite>
C:\GitHub\Servoventil\FW\servoventil_1.0.0/servoventil_1.0.0.ino:274
     servo.attach(SERVO_PIN);               // aktivovat servo
     dea:	0e 94 0c 02 	call	0x418	; 0x418 <Servo::attach(int) [clone .constprop.2]>
C:\GitHub\Servoventil\FW\servoventil_1.0.0/servoventil_1.0.0.ino:275
     servo.write(VENTIL_OTEVRENO_UHEL);     // otoÄit na pozici xx stupÅÅ¯
     dee:	89 e5       	ldi	r24, 0x59	; 89
     df0:	90 e0       	ldi	r25, 0x00	; 0
     df2:	0e 94 e9 00 	call	0x1d2	; 0x1d2 <Servo::write(int) [clone .constprop.4]>
C:\GitHub\Servoventil\FW\servoventil_1.0.0/servoventil_1.0.0.ino:281
     
     #ifdef DEBUG
       DPRINTLN("Oteviram ventil...");
     #endif

     digitalWrite(LED_LOWBAT_PIN,HIGH);     // zapnout LED
     df6:	61 e0       	ldi	r22, 0x01	; 1
     df8:	86 e0       	ldi	r24, 0x06	; 6
     dfa:	0e 94 6a 01 	call	0x2d4	; 0x2d4 <digitalWrite>
C:\GitHub\Servoventil\FW\servoventil_1.0.0/servoventil_1.0.0.ino:282
     delay(DOBA_PREBEHU_SERVA);             // poÄkÃ¡me neÅ¾ servo dojede
     dfe:	60 ed       	ldi	r22, 0xD0	; 208
     e00:	77 e0       	ldi	r23, 0x07	; 7
     e02:	80 e0       	ldi	r24, 0x00	; 0
     e04:	90 e0       	ldi	r25, 0x00	; 0
     e06:	0e 94 8e 02 	call	0x51c	; 0x51c <delay>
C:\GitHub\Servoventil\FW\servoventil_1.0.0/servoventil_1.0.0.ino:283
     digitalWrite(LED_LOWBAT_PIN,LOW);      // vypnout LED
     e0a:	60 e0       	ldi	r22, 0x00	; 0
     e0c:	86 e0       	ldi	r24, 0x06	; 6
     e0e:	0e 94 6a 01 	call	0x2d4	; 0x2d4 <digitalWrite>
C:\GitHub\Servoventil\FW\servoventil_1.0.0/servoventil_1.0.0.ino:285
     
     digitalWrite(SERVO_PIN,LOW);           // vypnout vÃ½stup PWM serva
     e12:	60 e0       	ldi	r22, 0x00	; 0
     e14:	83 e0       	ldi	r24, 0x03	; 3
     e16:	0e 94 6a 01 	call	0x2d4	; 0x2d4 <digitalWrite>
C:\GitHub\Servoventil\FW\servoventil_1.0.0/servoventil_1.0.0.ino:286
     digitalWrite(PWR_SERVO_ON_PIN,LOW);    // vypnout napÃ¡jenÃ­ serva
     e1a:	60 e0       	ldi	r22, 0x00	; 0
     e1c:	82 e0       	ldi	r24, 0x02	; 2
     e1e:	0e 94 6a 01 	call	0x2d4	; 0x2d4 <digitalWrite>
main():
C:\GitHub\Servoventil\FW\servoventil_1.0.0/servoventil_1.0.0.ino:289

     // CEKAT
     for(long t=0; t<ZapNaDobu*60; t++){    // pÅ: 1 minuta = 1000ms * 60 cyklÅ¯ -> 60 000ms
     e22:	c1 2c       	mov	r12, r1
     e24:	d1 2c       	mov	r13, r1
     e26:	76 01       	movw	r14, r12
setup():
     e28:	80 91 2f 01 	lds	r24, 0x012F	; 0x80012f <ZapNaDobu>
     e2c:	90 e0       	ldi	r25, 0x00	; 0
     e2e:	6c e3       	ldi	r22, 0x3C	; 60
     e30:	70 e0       	ldi	r23, 0x00	; 0
     e32:	0e 94 e1 07 	call	0xfc2	; 0xfc2 <__mulhi3>
     e36:	09 2e       	mov	r0, r25
     e38:	00 0c       	add	r0, r0
     e3a:	aa 0b       	sbc	r26, r26
     e3c:	bb 0b       	sbc	r27, r27
C:\GitHub\Servoventil\FW\servoventil_1.0.0/servoventil_1.0.0.ino:298
       delay(980);
       wdt_reset();                         // vynulovat ÄasovaÄ pro wdt
     }//end for

     // ZAVRIT
     digitalWrite(PWR_SERVO_ON_PIN, HIGH);  // zapnout napÃ¡jenÃ­ serva
     e3e:	61 e0       	ldi	r22, 0x01	; 1
C:\GitHub\Servoventil\FW\servoventil_1.0.0/servoventil_1.0.0.ino:289
     
     digitalWrite(SERVO_PIN,LOW);           // vypnout vÃ½stup PWM serva
     digitalWrite(PWR_SERVO_ON_PIN,LOW);    // vypnout napÃ¡jenÃ­ serva

     // CEKAT
     for(long t=0; t<ZapNaDobu*60; t++){    // pÅ: 1 minuta = 1000ms * 60 cyklÅ¯ -> 60 000ms
     e40:	c8 16       	cp	r12, r24
     e42:	d9 06       	cpc	r13, r25
     e44:	ea 06       	cpc	r14, r26
     e46:	fb 06       	cpc	r15, r27
     e48:	d4 f4       	brge	.+52     	; 0xe7e <main+0x3b2>
C:\GitHub\Servoventil\FW\servoventil_1.0.0/servoventil_1.0.0.ino:290
       digitalWrite(LED_LOWBAT_PIN,HIGH);   // zapnout krÃ¡tce LED (blik)
     e4a:	86 e0       	ldi	r24, 0x06	; 6
     e4c:	0e 94 6a 01 	call	0x2d4	; 0x2d4 <digitalWrite>
C:\GitHub\Servoventil\FW\servoventil_1.0.0/servoventil_1.0.0.ino:291
       delay(20);                           // 20 + 980 = 1000ms -> 1s
     e50:	64 e1       	ldi	r22, 0x14	; 20
     e52:	70 e0       	ldi	r23, 0x00	; 0
     e54:	80 e0       	ldi	r24, 0x00	; 0
     e56:	90 e0       	ldi	r25, 0x00	; 0
     e58:	0e 94 8e 02 	call	0x51c	; 0x51c <delay>
C:\GitHub\Servoventil\FW\servoventil_1.0.0/servoventil_1.0.0.ino:292
       digitalWrite(LED_LOWBAT_PIN,LOW);    // vypnout LED
     e5c:	60 e0       	ldi	r22, 0x00	; 0
     e5e:	86 e0       	ldi	r24, 0x06	; 6
     e60:	0e 94 6a 01 	call	0x2d4	; 0x2d4 <digitalWrite>
C:\GitHub\Servoventil\FW\servoventil_1.0.0/servoventil_1.0.0.ino:293
       delay(980);
     e64:	64 ed       	ldi	r22, 0xD4	; 212
     e66:	73 e0       	ldi	r23, 0x03	; 3
     e68:	80 e0       	ldi	r24, 0x00	; 0
     e6a:	90 e0       	ldi	r25, 0x00	; 0
     e6c:	0e 94 8e 02 	call	0x51c	; 0x51c <delay>
C:\GitHub\Servoventil\FW\servoventil_1.0.0/servoventil_1.0.0.ino:294
       wdt_reset();                         // vynulovat ÄasovaÄ pro wdt
     e70:	a8 95       	wdr
C:\GitHub\Servoventil\FW\servoventil_1.0.0/servoventil_1.0.0.ino:289
     
     digitalWrite(SERVO_PIN,LOW);           // vypnout vÃ½stup PWM serva
     digitalWrite(PWR_SERVO_ON_PIN,LOW);    // vypnout napÃ¡jenÃ­ serva

     // CEKAT
     for(long t=0; t<ZapNaDobu*60; t++){    // pÅ: 1 minuta = 1000ms * 60 cyklÅ¯ -> 60 000ms
     e72:	9f ef       	ldi	r25, 0xFF	; 255
     e74:	c9 1a       	sub	r12, r25
     e76:	d9 0a       	sbc	r13, r25
     e78:	e9 0a       	sbc	r14, r25
     e7a:	f9 0a       	sbc	r15, r25
     e7c:	d5 cf       	rjmp	.-86     	; 0xe28 <main+0x35c>
C:\GitHub\Servoventil\FW\servoventil_1.0.0/servoventil_1.0.0.ino:298
       delay(980);
       wdt_reset();                         // vynulovat ÄasovaÄ pro wdt
     }//end for

     // ZAVRIT
     digitalWrite(PWR_SERVO_ON_PIN, HIGH);  // zapnout napÃ¡jenÃ­ serva
     e7e:	82 e0       	ldi	r24, 0x02	; 2
     e80:	0e 94 6a 01 	call	0x2d4	; 0x2d4 <digitalWrite>
C:\GitHub\Servoventil\FW\servoventil_1.0.0/servoventil_1.0.0.ino:299
     servo.attach(SERVO_PIN);               // aktivovat servo
     e84:	0e 94 0c 02 	call	0x418	; 0x418 <Servo::attach(int) [clone .constprop.2]>
C:\GitHub\Servoventil\FW\servoventil_1.0.0/servoventil_1.0.0.ino:300
     servo.write(VENTIL_ZAVRENO_UHEL);      // otoÄit na pozici xx stupÅÅ¯
     e88:	83 e0       	ldi	r24, 0x03	; 3
     e8a:	90 e0       	ldi	r25, 0x00	; 0
     e8c:	0e 94 e9 00 	call	0x1d2	; 0x1d2 <Servo::write(int) [clone .constprop.4]>
C:\GitHub\Servoventil\FW\servoventil_1.0.0/servoventil_1.0.0.ino:305
     #ifdef DEBUG
       DPRINTLN("Zaviram ventil...");
     #endif

     digitalWrite(LED_LOWBAT_PIN,HIGH);     // zapnout LED
     e90:	61 e0       	ldi	r22, 0x01	; 1
     e92:	86 e0       	ldi	r24, 0x06	; 6
     e94:	0e 94 6a 01 	call	0x2d4	; 0x2d4 <digitalWrite>
C:\GitHub\Servoventil\FW\servoventil_1.0.0/servoventil_1.0.0.ino:306
     delay(DOBA_PREBEHU_SERVA);             // poÄkÃ¡me neÅ¾ servo dojede
     e98:	60 ed       	ldi	r22, 0xD0	; 208
     e9a:	77 e0       	ldi	r23, 0x07	; 7
     e9c:	80 e0       	ldi	r24, 0x00	; 0
     e9e:	90 e0       	ldi	r25, 0x00	; 0
     ea0:	0e 94 8e 02 	call	0x51c	; 0x51c <delay>
C:\GitHub\Servoventil\FW\servoventil_1.0.0/servoventil_1.0.0.ino:307
     digitalWrite(LED_LOWBAT_PIN,LOW);      // vypnout LED
     ea4:	60 e0       	ldi	r22, 0x00	; 0
     ea6:	86 e0       	ldi	r24, 0x06	; 6
     ea8:	0e 94 6a 01 	call	0x2d4	; 0x2d4 <digitalWrite>
C:\GitHub\Servoventil\FW\servoventil_1.0.0/servoventil_1.0.0.ino:309

     digitalWrite(SERVO_PIN,LOW);           // vypnout vÃ½stup PWM serva
     eac:	60 e0       	ldi	r22, 0x00	; 0
     eae:	83 e0       	ldi	r24, 0x03	; 3
     eb0:	0e 94 6a 01 	call	0x2d4	; 0x2d4 <digitalWrite>
C:\GitHub\Servoventil\FW\servoventil_1.0.0/servoventil_1.0.0.ino:310
     digitalWrite(PWR_SERVO_ON_PIN,LOW);    // vypnout napÃ¡jenÃ­ serva
     eb4:	60 e0       	ldi	r22, 0x00	; 0
     eb6:	82 e0       	ldi	r24, 0x02	; 2
     eb8:	0e 94 6a 01 	call	0x2d4	; 0x2d4 <digitalWrite>
C:\GitHub\Servoventil\FW\servoventil_1.0.0/servoventil_1.0.0.ino:318
  #ifdef DEBUG
    DPRINT("Vypinam napajeni!");
    delay(1000);
  #endif
  
  digitalWrite(PWR_ON_PIN,LOW);             // vypnout napÃ¡jenÃ­ CPU
     ebc:	60 e0       	ldi	r22, 0x00	; 0
     ebe:	84 e0       	ldi	r24, 0x04	; 4
     ec0:	0e 94 6a 01 	call	0x2d4	; 0x2d4 <digitalWrite>
     ec4:	ff cf       	rjmp	.-2      	; 0xec4 <main+0x3f8>

00000ec6 <_GLOBAL__sub_I_SLEEP_PER>:
_GLOBAL__sub_I_SLEEP_PER():
C:\Users\táta\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\libraries\Servo_ATTinyCore\src\avr/Servo_ATTinyCore.cpp:1205

/****************** end of static functions ******************************/

Servo::Servo()
{
  if( ServoCount < MAX_SERVOS) {
     ec6:	80 91 25 01 	lds	r24, 0x0125	; 0x800125 <ServoCount>
     eca:	8c 30       	cpi	r24, 0x0C	; 12
     ecc:	98 f4       	brcc	.+38     	; 0xef4 <_GLOBAL__sub_I_SLEEP_PER+0x2e>
C:\Users\táta\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\libraries\Servo_ATTinyCore\src\avr/Servo_ATTinyCore.cpp:1206
    this->servoIndex = ServoCount++;                    // assign a servo index to this instance
     ece:	91 e0       	ldi	r25, 0x01	; 1
     ed0:	98 0f       	add	r25, r24
     ed2:	90 93 25 01 	sts	0x0125, r25	; 0x800125 <ServoCount>
     ed6:	80 93 54 01 	sts	0x0154, r24	; 0x800154 <servo>
C:\Users\táta\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\libraries\Servo_ATTinyCore\src\avr/Servo_ATTinyCore.cpp:1207
    servos[this->servoIndex].ticks = usToTicks(DEFAULT_PULSE_WIDTH);   // store default values  - 12 Aug 2009
     eda:	90 e0       	ldi	r25, 0x00	; 0
     edc:	63 e0       	ldi	r22, 0x03	; 3
     ede:	70 e0       	ldi	r23, 0x00	; 0
     ee0:	0e 94 e1 07 	call	0xfc2	; 0xfc2 <__mulhi3>
     ee4:	80 5d       	subi	r24, 0xD0	; 208
     ee6:	9e 4f       	sbci	r25, 0xFE	; 254
     ee8:	2c ed       	ldi	r18, 0xDC	; 220
     eea:	35 e0       	ldi	r19, 0x05	; 5
     eec:	fc 01       	movw	r30, r24
     eee:	32 83       	std	Z+2, r19	; 0x02
     ef0:	21 83       	std	Z+1, r18	; 0x01
     ef2:	08 95       	ret
C:\Users\táta\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\libraries\Servo_ATTinyCore\src\avr/Servo_ATTinyCore.cpp:1210
  }
  else
    this->servoIndex = INVALID_SERVO ;  // too many servos
     ef4:	8f ef       	ldi	r24, 0xFF	; 255
     ef6:	80 93 54 01 	sts	0x0154, r24	; 0x800154 <servo>
C:\GitHub\Servoventil\FW\servoventil_1.0.0/servoventil_1.0.0.ino:322
  while(1);                                 // pokud nespadne CPU sÃ¡m, tak WDT ho schodÃ­
}//konec setup

void loop(){} // konec loop
     efa:	08 95       	ret

00000efc <__mulsi3>:
__mulsi3():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr35/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:445
     efc:	ee 27       	eor	r30, r30
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr35/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:446
     efe:	ff 27       	eor	r31, r31

00000f00 <__mulsi3_helper>:
__mulsi3_helper():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr35/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:451
     f00:	aa 27       	eor	r26, r26
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr35/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:452
     f02:	bb 27       	eor	r27, r27
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr35/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:453
     f04:	08 c0       	rjmp	.+16     	; 0xf16 <__mulsi3_helper+0x16>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr35/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:457
     f06:	a2 0f       	add	r26, r18
     f08:	b3 1f       	adc	r27, r19
     f0a:	e4 1f       	adc	r30, r20
     f0c:	f5 1f       	adc	r31, r21
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr35/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:460
     f0e:	22 0f       	add	r18, r18
     f10:	33 1f       	adc	r19, r19
     f12:	44 1f       	adc	r20, r20
     f14:	55 1f       	adc	r21, r21
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr35/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:463
     f16:	96 95       	lsr	r25
     f18:	87 95       	ror	r24
     f1a:	77 95       	ror	r23
     f1c:	67 95       	ror	r22
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr35/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:465
     f1e:	98 f3       	brcs	.-26     	; 0xf06 <__mulsi3_helper+0x6>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr35/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:467
     f20:	70 40       	sbci	r23, 0x00	; 0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr35/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:468
     f22:	a9 f7       	brne	.-22     	; 0xf0e <__mulsi3_helper+0xe>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr35/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:469
     f24:	00 97       	sbiw	r24, 0x00	; 0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr35/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:470
     f26:	99 f7       	brne	.-26     	; 0xf0e <__mulsi3_helper+0xe>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr35/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:473
     f28:	bd 01       	movw	r22, r26
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr35/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:474
     f2a:	cf 01       	movw	r24, r30
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr35/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:480
     f2c:	08 95       	ret

00000f2e <__divmodsi4>:
__divmodsi4():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr35/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1686
     f2e:	05 2e       	mov	r0, r21
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr35/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1687
     f30:	97 fb       	bst	r25, 7
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr35/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1688
     f32:	1e f4       	brtc	.+6      	; 0xf3a <__divmodsi4+0xc>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr35/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1689
     f34:	00 94       	com	r0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr35/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1690
     f36:	0e 94 ae 07 	call	0xf5c	; 0xf5c <__negsi2>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr35/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1692
     f3a:	57 fd       	sbrc	r21, 7
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr35/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1693
     f3c:	07 d0       	rcall	.+14     	; 0xf4c <__divmodsi4_neg2>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr35/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1694
     f3e:	0e 94 b6 07 	call	0xf6c	; 0xf6c <__udivmodsi4>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr35/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1695
     f42:	07 fc       	sbrc	r0, 7
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr35/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1696
     f44:	03 d0       	rcall	.+6      	; 0xf4c <__divmodsi4_neg2>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr35/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1697
     f46:	4e f4       	brtc	.+18     	; 0xf5a <__divmodsi4_exit>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr35/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1698
     f48:	0c 94 ae 07 	jmp	0xf5c	; 0xf5c <__negsi2>

00000f4c <__divmodsi4_neg2>:
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr35/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1701
     f4c:	50 95       	com	r21
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr35/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1702
     f4e:	40 95       	com	r20
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr35/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1703
     f50:	30 95       	com	r19
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr35/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1704
     f52:	21 95       	neg	r18
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr35/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1705
     f54:	3f 4f       	sbci	r19, 0xFF	; 255
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr35/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1706
     f56:	4f 4f       	sbci	r20, 0xFF	; 255
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr35/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1707
     f58:	5f 4f       	sbci	r21, 0xFF	; 255

00000f5a <__divmodsi4_exit>:
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr35/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1709
     f5a:	08 95       	ret

00000f5c <__negsi2>:
__negsi2():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr35/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1718
     f5c:	90 95       	com	r25
     f5e:	80 95       	com	r24
     f60:	70 95       	com	r23
     f62:	61 95       	neg	r22
     f64:	7f 4f       	sbci	r23, 0xFF	; 255
     f66:	8f 4f       	sbci	r24, 0xFF	; 255
     f68:	9f 4f       	sbci	r25, 0xFF	; 255
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr35/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1719
     f6a:	08 95       	ret

00000f6c <__udivmodsi4>:
__udivmodsi4():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr35/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1638
     f6c:	a1 e2       	ldi	r26, 0x21	; 33
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr35/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1639
     f6e:	1a 2e       	mov	r1, r26
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr35/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1640
     f70:	aa 1b       	sub	r26, r26
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr35/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1641
     f72:	bb 1b       	sub	r27, r27
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr35/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1642
     f74:	fd 01       	movw	r30, r26
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr35/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1644
     f76:	0d c0       	rjmp	.+26     	; 0xf92 <__udivmodsi4_ep>

00000f78 <__udivmodsi4_loop>:
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr35/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1646
     f78:	aa 1f       	adc	r26, r26
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr35/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1647
     f7a:	bb 1f       	adc	r27, r27
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr35/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1648
     f7c:	ee 1f       	adc	r30, r30
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr35/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1649
     f7e:	ff 1f       	adc	r31, r31
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr35/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1650
     f80:	a2 17       	cp	r26, r18
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr35/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1651
     f82:	b3 07       	cpc	r27, r19
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr35/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1652
     f84:	e4 07       	cpc	r30, r20
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr35/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1653
     f86:	f5 07       	cpc	r31, r21
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr35/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1654
     f88:	20 f0       	brcs	.+8      	; 0xf92 <__udivmodsi4_ep>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr35/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1655
     f8a:	a2 1b       	sub	r26, r18
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr35/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1656
     f8c:	b3 0b       	sbc	r27, r19
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr35/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1657
     f8e:	e4 0b       	sbc	r30, r20
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr35/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1658
     f90:	f5 0b       	sbc	r31, r21

00000f92 <__udivmodsi4_ep>:
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr35/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1660
     f92:	66 1f       	adc	r22, r22
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr35/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1661
     f94:	77 1f       	adc	r23, r23
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr35/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1662
     f96:	88 1f       	adc	r24, r24
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr35/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1663
     f98:	99 1f       	adc	r25, r25
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr35/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1664
     f9a:	1a 94       	dec	r1
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr35/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1665
     f9c:	69 f7       	brne	.-38     	; 0xf78 <__udivmodsi4_loop>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr35/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1667
     f9e:	60 95       	com	r22
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr35/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1668
     fa0:	70 95       	com	r23
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr35/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1669
     fa2:	80 95       	com	r24
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr35/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1670
     fa4:	90 95       	com	r25
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr35/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1672
     fa6:	9b 01       	movw	r18, r22
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr35/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1674
     fa8:	ac 01       	movw	r20, r24
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr35/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1676
     faa:	bd 01       	movw	r22, r26
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr35/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1678
     fac:	cf 01       	movw	r24, r30
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr35/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1680
     fae:	08 95       	ret

00000fb0 <__mulqi3>:
__mulqi3():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr35/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:224
     fb0:	00 24       	eor	r0, r0

00000fb2 <__mulqi3_loop>:
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr35/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:226
     fb2:	80 fd       	sbrc	r24, 0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr35/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:227
     fb4:	06 0e       	add	r0, r22
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr35/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:228
     fb6:	66 0f       	add	r22, r22
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr35/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:229
     fb8:	11 f0       	breq	.+4      	; 0xfbe <__mulqi3_exit>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr35/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:230
     fba:	86 95       	lsr	r24
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr35/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:231
     fbc:	d1 f7       	brne	.-12     	; 0xfb2 <__mulqi3_loop>

00000fbe <__mulqi3_exit>:
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr35/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:233
     fbe:	80 2d       	mov	r24, r0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr35/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:234
     fc0:	08 95       	ret

00000fc2 <__mulhi3>:
__mulhi3():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr35/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:312
     fc2:	00 24       	eor	r0, r0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr35/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:313
     fc4:	55 27       	eor	r21, r21
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr35/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:314
     fc6:	04 c0       	rjmp	.+8      	; 0xfd0 <__mulhi3+0xe>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr35/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:317
     fc8:	08 0e       	add	r0, r24
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr35/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:318
     fca:	59 1f       	adc	r21, r25
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr35/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:320
     fcc:	88 0f       	add	r24, r24
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr35/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:321
     fce:	99 1f       	adc	r25, r25
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr35/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:324
     fd0:	00 97       	sbiw	r24, 0x00	; 0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr35/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:325
     fd2:	29 f0       	breq	.+10     	; 0xfde <__mulhi3+0x1c>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr35/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:328
     fd4:	76 95       	lsr	r23
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr35/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:329
     fd6:	67 95       	ror	r22
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr35/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:331
     fd8:	b8 f3       	brcs	.-18     	; 0xfc8 <__mulhi3+0x6>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr35/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:335
     fda:	71 05       	cpc	r23, r1
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr35/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:337
     fdc:	b9 f7       	brne	.-18     	; 0xfcc <__mulhi3+0xa>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr35/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:340
     fde:	80 2d       	mov	r24, r0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr35/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:341
     fe0:	95 2f       	mov	r25, r21
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr35/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:342
     fe2:	08 95       	ret

00000fe4 <__udivmodqi4>:
__udivmodqi4():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr35/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1346
     fe4:	99 1b       	sub	r25, r25
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr35/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1347
     fe6:	79 e0       	ldi	r23, 0x09	; 9
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr35/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1348
     fe8:	04 c0       	rjmp	.+8      	; 0xff2 <__udivmodqi4_ep>

00000fea <__udivmodqi4_loop>:
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr35/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1350
     fea:	99 1f       	adc	r25, r25
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr35/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1351
     fec:	96 17       	cp	r25, r22
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr35/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1352
     fee:	08 f0       	brcs	.+2      	; 0xff2 <__udivmodqi4_ep>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr35/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1353
     ff0:	96 1b       	sub	r25, r22

00000ff2 <__udivmodqi4_ep>:
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr35/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1355
     ff2:	88 1f       	adc	r24, r24
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr35/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1356
     ff4:	7a 95       	dec	r23
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr35/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1357
     ff6:	c9 f7       	brne	.-14     	; 0xfea <__udivmodqi4_loop>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr35/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1358
     ff8:	80 95       	com	r24
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr35/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1360
     ffa:	08 95       	ret

00000ffc <__tablejump2__>:
__tablejump2__():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr35/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2296
     ffc:	ee 0f       	add	r30, r30
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr35/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2297
     ffe:	ff 1f       	adc	r31, r31
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr35/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2328
    1000:	05 90       	lpm	r0, Z+
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr35/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2329
    1002:	f4 91       	lpm	r31, Z
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr35/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2330
    1004:	e0 2d       	mov	r30, r0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr35/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2331
    1006:	09 94       	ijmp

00001008 <_exit>:
exit():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr35/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2278
    1008:	f8 94       	cli

0000100a <__stop_program>:
__stop_program():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr35/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2280
    100a:	ff cf       	rjmp	.-2      	; 0x100a <__stop_program>
